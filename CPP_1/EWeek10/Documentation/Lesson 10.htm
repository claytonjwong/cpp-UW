<!DOCTYPE html>
<!-- saved from url=(0076)https://canvas.uw.edu/courses/1177926/pages/lesson-10?module_item_id=7889578 -->
<html class="" dir="ltr" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Lesson 10: CPROGRM 711 A Wi 18: C++ Programming: Introduction</title>
  <!--[if lte IE 9]> <meta http-equiv=refresh content="0; URL=/ie-9-is-not-supported.html" /> <![endif]-->
  <link rel="preload" href="https://du11hjcvx0uqb.cloudfront.net/dist/fonts/lato/latin/LatoLatin-Regular-3cd3657802.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="shortcut icon" type="image/x-icon" href="https://instructure-uploads.s3.amazonaws.com/account_100000000083919/attachments/37312004/favicon.ico?AWSAccessKeyId=AKIAJFNFXH2V2O7RPCAA&amp;Expires=1939374366&amp;Signature=lNl7iuCda9spDgRONbwVvr490LM%3D&amp;response-cache-control=Cache-Control%3Amax-age%3D473364000.0%2C%20public&amp;response-expires=473364000.0">
  <link rel="apple-touch-icon" href="https://instructure-uploads.s3.amazonaws.com/account_100000000083919/attachments/37312005/Canvas-MobileHome.png?AWSAccessKeyId=AKIAJFNFXH2V2O7RPCAA&amp;Expires=1939374366&amp;Signature=jwVDIJvM6uIaOoE%2FSW94uwVcHU0%3D&amp;response-cache-control=Cache-Control%3Amax-age%3D473364000.0%2C%20public&amp;response-expires=473364000.0">
  
  <link rel="stylesheet" media="all" href="./Lesson 10_files/variables-750d72b9d3e5d522f965bf904110c132.css">
  <link rel="stylesheet" media="all" href="./Lesson 10_files/common-d446d06ede.css">
  <script type="text/javascript" async="" src="./Lesson 10_files/ga.js"></script><script>
//<![CDATA[

!function(){
  function get(u){document.write('<scr'+'ipt src="'+ u +'"></sc'+'ript>')}
  var o,s,v;
  if (!(window.Promise && Object.assign && Object.values && [].find && [].includes && (o={},s=Symbol(),v={},o[s]=v,o[s]===v) && (function f(){}).bind().name==='bound f')) {
    get("https://du11hjcvx0uqb.cloudfront.net/dist/ie11-polyfill-9f640d24ea.js");
  }
  window.fetch || get("https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js");
}();
      
//]]>
</script>
  <script src="./Lesson 10_files/lato-fontfaceobserver-ed903d58c4.js" async="async"></script>
  
  <meta name="apple-itunes-app" content="app-id=480883488">
<link rel="manifest" href="https://canvas.uw.edu/web-app-manifest/manifest.json">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#008EE2">
  <link rel="stylesheet" media="all" href="./Lesson 10_files/wiki_page-46e7e026f6.css">
  
  <link rel="stylesheet" media="all" href="./Lesson 10_files/custom.css">
<link rel="stylesheet" media="all" href="./Lesson 10_files/custom(1).css">
  <script>
    function _earlyClick(e){
      var c = e.target
      while (c && c.ownerDocument) {
        if (c.getAttribute('href') == '#' || c.getAttribute('data-method')) {
          e.preventDefault()
          (_earlyClick.clicks = _earlyClick.clicks || []).push(c)
          break
        }
        c = c.parentNode
      }
    }
    document.addEventListener('click', _earlyClick)
  </script>
  <script src="./Lesson 10_files/variables-750d72b9d3e5d522f965bf904110c132.js" defer="defer"></script>
  <script src="./Lesson 10_files/vendor.bundle-e87d116ea9.js" defer="defer"></script>
<script src="./Lesson 10_files/Los_Angeles-d9cac65c52.js" defer="defer"></script>
<script src="./Lesson 10_files/en_US-80a0ce259b.js" defer="defer"></script>
<script src="./Lesson 10_files/appBootstrap.bundle-0661001892.js" defer="defer"></script>
<script src="./Lesson 10_files/common.bundle-f89441110c.js" defer="defer"></script>
<script src="./Lesson 10_files/wiki_page_show.bundle-230f977ba8.js" defer="defer"></script>
<style type="text/css"></style><style type="text/css">.mejs-offscreen{clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);clip-path:polygon(0px 0,0 0,0 0,0 0);position:absolute!important;height:1px;width:1px;overflow:hidden}.mejs-container{position:relative;background:#000;font-family:Helvetica,Arial,serif;text-align:left;vertical-align:top;text-indent:0}.mejs-fill-container,.mejs-fill-container .mejs-container{width:100%;height:100%}.mejs-fill-container{overflow:hidden}.mejs-container:focus{outline:0}.me-plugin{position:absolute}.mejs-embed,.mejs-embed body{width:100%;height:100%;margin:0;padding:0;background:#000;overflow:hidden}.mejs-fullscreen{overflow:hidden!important}.mejs-container-fullscreen{position:fixed;left:0;top:0;right:0;bottom:0;overflow:hidden;z-index:1000}.mejs-container-fullscreen .mejs-mediaelement,.mejs-container-fullscreen video{width:100%;height:100%}.mejs-clear{clear:both}.mejs-background{position:absolute;top:0;left:0}.mejs-mediaelement{position:absolute;top:0;left:0;width:100%;height:100%}.mejs-poster{position:absolute;top:0;left:0;background-size:contain;background-position:50% 50%;background-repeat:no-repeat}:root .mejs-poster img{display:none}.mejs-poster img{border:0;padding:0}.mejs-overlay{position:absolute;top:0;left:0}.mejs-overlay-play{cursor:pointer}.mejs-overlay-button{position:absolute;top:50%;left:50%;width:100px;height:100px;margin:-50px 0 0 -50px;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/746c3af7a145a09239a36e5ef61cfea0.svg) no-repeat}.no-svg .mejs-overlay-button{background-image:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/716436fb3df0d29e6b37dd62d952676a.png)}.mejs-overlay:hover .mejs-overlay-button{background-position:0 -100px}.mejs-overlay-loading{position:absolute;top:50%;left:50%;width:80px;height:80px;margin:-40px 0 0 -40px;background:#333;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(0,0,0,.9);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(50,50,50,.9)),to(rgba(0,0,0,.9)));background:-webkit-linear-gradient(top,rgba(50,50,50,.9),rgba(0,0,0,.9));background:-moz-linear-gradient(top,rgba(50,50,50,.9),rgba(0,0,0,.9));background:-o-linear-gradient(top,rgba(50,50,50,.9),rgba(0,0,0,.9));background:-ms-linear-gradient(top,rgba(50,50,50,.9),rgba(0,0,0,.9));background:linear-gradient(rgba(50,50,50,.9),rgba(0,0,0,.9))}.mejs-overlay-loading span{display:block;width:80px;height:80px;background:transparent url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/76b326f4d44222126fee21076595bef5.gif) 50% 50% no-repeat}.mejs-container .mejs-controls{position:absolute;list-style-type:none;margin:0;padding:0;bottom:0;left:0;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(0,0,0,.7);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(50,50,50,.7)),to(rgba(0,0,0,.7)));background:-webkit-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-moz-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-o-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-ms-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:linear-gradient(rgba(50,50,50,.7),rgba(0,0,0,.7));height:30px;width:100%}.mejs-container .mejs-controls div{list-style-type:none;background-image:none;display:block;float:left;margin:0;padding:0;width:26px;height:26px;font-size:11px;line-height:11px;font-family:Helvetica,Arial,serif;border:0}.mejs-controls .mejs-button button{cursor:pointer;display:block;font-size:0;line-height:0;text-decoration:none;margin:7px 5px;padding:0;position:absolute;height:16px;width:16px;border:0;background:transparent url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/40f56f5a736da4effeb790cedb8a52f0.svg) no-repeat}.no-svg .mejs-controls .mejs-button button{background-image:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/24a0227fbdd3acfd86ff03fc3fc6c8a4.png)}.mejs-controls .mejs-button button:focus{outline:dotted 1px #999}.mejs-container .mejs-controls .mejs-time{color:#fff;display:block;height:17px;width:auto;padding:10px 3px 0;overflow:hidden;text-align:center;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}.mejs-container .mejs-controls .mejs-time a{color:#fff;font-size:11px;line-height:12px;display:block;float:left;margin:1px 2px 0 0;width:auto}.mejs-controls .mejs-play button{background-position:0 0}.mejs-controls .mejs-pause button{background-position:0 -16px}.mejs-controls .mejs-stop button{background-position:-112px 0}.mejs-controls div.mejs-time-rail{direction:ltr;width:200px;padding-top:5px}.mejs-controls .mejs-time-rail span,.mejs-controls .mejs-time-rail a{display:block;position:absolute;width:180px;height:10px;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;cursor:pointer}.mejs-controls .mejs-time-rail .mejs-time-total{margin:5px;background:#333;background:rgba(50,50,50,.8);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(30,30,30,.8)),to(rgba(60,60,60,.8)));background:-webkit-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-moz-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-o-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-ms-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:linear-gradient(rgba(30,30,30,.8),rgba(60,60,60,.8))}.mejs-controls .mejs-time-rail .mejs-time-buffering{width:100%;background-image:-o-linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,.15)),color-stop(0.75,rgba(255,255,255,.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:15px 15px;-moz-background-size:15px 15px;-o-background-size:15px 15px;background-size:15px 15px;-webkit-animation:buffering-stripes 2s linear infinite;-moz-animation:buffering-stripes 2s linear infinite;-ms-animation:buffering-stripes 2s linear infinite;-o-animation:buffering-stripes 2s linear infinite;animation:buffering-stripes 2s linear infinite}@-webkit-keyframes buffering-stripes{from{background-position:0 0}to{background-position:30px 0}}@-moz-keyframes buffering-stripes{from{background-position:0 0}to{background-position:30px 0}}@-ms-keyframes buffering-stripes{from{background-position:0 0}to{background-position:30px 0}}@-o-keyframes buffering-stripes{from{background-position:0 0}to{background-position:30px 0}}@keyframes buffering-stripes{from{background-position:0 0}to{background-position:30px 0}}.mejs-controls .mejs-time-rail .mejs-time-loaded{background:#3caac8;background:rgba(60,170,200,.8);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(44,124,145,.8)),to(rgba(78,183,212,.8)));background:-webkit-linear-gradient(top,rgba(44,124,145,.8),rgba(78,183,212,.8));background:-moz-linear-gradient(top,rgba(44,124,145,.8),rgba(78,183,212,.8));background:-o-linear-gradient(top,rgba(44,124,145,.8),rgba(78,183,212,.8));background:-ms-linear-gradient(top,rgba(44,124,145,.8),rgba(78,183,212,.8));background:linear-gradient(rgba(44,124,145,.8),rgba(78,183,212,.8));width:0}.mejs-controls .mejs-time-rail .mejs-time-current{background:#fff;background:rgba(255,255,255,.8);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(255,255,255,.9)),to(rgba(200,200,200,.8)));background:-webkit-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-moz-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-o-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-ms-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:linear-gradient(rgba(255,255,255,.9),rgba(200,200,200,.8));width:0}.mejs-controls .mejs-time-rail .mejs-time-handle{display:none;position:absolute;margin:0;width:10px;background:#fff;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;cursor:pointer;border:solid 2px #333;top:-2px;text-align:center}.mejs-controls .mejs-time-rail .mejs-time-float{position:absolute;display:none;background:#eee;width:36px;height:17px;border:solid 1px #333;top:-26px;margin-left:-18px;text-align:center;color:#111}.mejs-controls .mejs-time-rail .mejs-time-float-current{margin:2px;width:30px;display:block;text-align:center;left:0}.mejs-controls .mejs-time-rail .mejs-time-float-corner{position:absolute;display:block;width:0;height:0;line-height:0;border:solid 5px #eee;border-color:#eee transparent transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;top:15px;left:13px}.mejs-long-video .mejs-controls .mejs-time-rail .mejs-time-float{width:48px}.mejs-long-video .mejs-controls .mejs-time-rail .mejs-time-float-current{width:44px}.mejs-long-video .mejs-controls .mejs-time-rail .mejs-time-float-corner{left:18px}.mejs-controls .mejs-fullscreen-button button{background-position:-32px 0}.mejs-controls .mejs-unfullscreen button{background-position:-32px -16px}.mejs-controls .mejs-volume-button{}.mejs-controls .mejs-mute button{background-position:-16px -16px}.mejs-controls .mejs-unmute button{background-position:-16px 0}.mejs-controls .mejs-volume-button{position:relative}.mejs-controls .mejs-volume-button .mejs-volume-slider{height:115px;width:25px;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;top:-115px;left:0;z-index:1;position:absolute;margin:0}.mejs-controls .mejs-volume-button:hover{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.mejs-controls .mejs-volume-button .mejs-volume-slider .mejs-volume-total{position:absolute;left:11px;top:8px;width:2px;height:100px;background:#ddd;background:rgba(255,255,255,.5);margin:0}.mejs-controls .mejs-volume-button .mejs-volume-slider .mejs-volume-current{position:absolute;left:11px;top:8px;width:2px;height:100px;background:#ddd;background:rgba(255,255,255,.9);margin:0}.mejs-controls .mejs-volume-button .mejs-volume-slider .mejs-volume-handle{position:absolute;left:4px;top:-3px;width:16px;height:6px;background:#ddd;background:rgba(255,255,255,.9);cursor:N-resize;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;margin:0}.mejs-controls a.mejs-horizontal-volume-slider{height:26px;width:56px;position:relative;display:block;float:left;vertical-align:middle}.mejs-controls .mejs-horizontal-volume-slider .mejs-horizontal-volume-total{position:absolute;left:0;top:11px;width:50px;height:8px;margin:0;padding:0;font-size:1px;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;background:#333;background:rgba(50,50,50,.8);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(30,30,30,.8)),to(rgba(60,60,60,.8)));background:-webkit-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-moz-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-o-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:-ms-linear-gradient(top,rgba(30,30,30,.8),rgba(60,60,60,.8));background:linear-gradient(rgba(30,30,30,.8),rgba(60,60,60,.8))}.mejs-controls .mejs-horizontal-volume-slider .mejs-horizontal-volume-current{position:absolute;left:0;top:11px;width:50px;height:8px;margin:0;padding:0;font-size:1px;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;background:#fff;background:rgba(255,255,255,.8);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(255,255,255,.9)),to(rgba(200,200,200,.8)));background:-webkit-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-moz-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-o-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:-ms-linear-gradient(top,rgba(255,255,255,.9),rgba(200,200,200,.8));background:linear-gradient(rgba(255,255,255,.9),rgba(200,200,200,.8))}.mejs-controls .mejs-horizontal-volume-slider .mejs-horizontal-volume-handle{display:none}.mejs-controls .mejs-captions-button{position:relative}.mejs-controls .mejs-captions-button button{background-position:-48px 0}.mejs-controls .mejs-captions-button .mejs-captions-selector{position:absolute;bottom:26px;right:-51px;width:85px;height:100px;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);border:solid 1px transparent;padding:10px 10px 0;overflow:hidden;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.mejs-controls .mejs-captions-button .mejs-captions-selector ul{margin:0;padding:0;display:block;list-style-type:none!important;overflow:hidden}.mejs-controls .mejs-captions-button .mejs-captions-selector ul li{margin:0 0 6px;padding:0;list-style-type:none!important;display:block;color:#fff;overflow:hidden}.mejs-controls .mejs-captions-button .mejs-captions-selector ul li input{clear:both;float:left;margin:3px 3px 0 5px}.mejs-controls .mejs-captions-button .mejs-captions-selector ul li label{width:55px;float:left;padding:4px 0 0;line-height:15px;font-family:Helvetica,Arial,serif;font-size:10px}.mejs-controls .mejs-captions-button .mejs-captions-translations{font-size:10px;margin:0 0 5px}.mejs-chapters{position:absolute;top:0;left:0;border-right:solid 1px #fff;width:10000px;z-index:1}.mejs-chapters .mejs-chapter{position:absolute;float:left;background:#222;background:rgba(0,0,0,.7);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(50,50,50,.7)),to(rgba(0,0,0,.7)));background:-webkit-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-moz-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-o-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:-ms-linear-gradient(top,rgba(50,50,50,.7),rgba(0,0,0,.7));background:linear-gradient(rgba(50,50,50,.7),rgba(0,0,0,.7));filter:progid:DXImageTransform.Microsoft.Gradient(GradientType=0, startColorstr=#323232, endColorstr=#000000);overflow:hidden;border:0}.mejs-chapters .mejs-chapter .mejs-chapter-block{font-size:11px;color:#fff;padding:5px;display:block;border-right:solid 1px #333;border-bottom:solid 1px #333;cursor:pointer}.mejs-chapters .mejs-chapter .mejs-chapter-block-last{border-right:0}.mejs-chapters .mejs-chapter .mejs-chapter-block:hover{background:#666;background:rgba(102,102,102,.7);background:-webkit-gradient(linear,0 0,0 100%,from(rgba(102,102,102,.7)),to(rgba(50,50,50,.6)));background:-webkit-linear-gradient(top,rgba(102,102,102,.7),rgba(50,50,50,.6));background:-moz-linear-gradient(top,rgba(102,102,102,.7),rgba(50,50,50,.6));background:-o-linear-gradient(top,rgba(102,102,102,.7),rgba(50,50,50,.6));background:-ms-linear-gradient(top,rgba(102,102,102,.7),rgba(50,50,50,.6));background:linear-gradient(rgba(102,102,102,.7),rgba(50,50,50,.6));filter:progid:DXImageTransform.Microsoft.Gradient(GradientType=0, startColorstr=#666666, endColorstr=#323232)}.mejs-chapters .mejs-chapter .mejs-chapter-block .ch-title{font-size:12px;font-weight:700;display:block;white-space:nowrap;text-overflow:ellipsis;margin:0 0 3px;line-height:12px}.mejs-chapters .mejs-chapter .mejs-chapter-block .ch-timespan{font-size:12px;line-height:12px;margin:3px 0 4px;display:block;white-space:nowrap;text-overflow:ellipsis}.mejs-captions-layer{position:absolute;bottom:0;left:0;text-align:center;line-height:20px;font-size:16px;color:#fff}.mejs-captions-layer a{color:#fff;text-decoration:underline}.mejs-captions-layer[lang=ar]{font-size:20px;font-weight:400}.mejs-captions-position{position:absolute;width:100%;bottom:15px;left:0}.mejs-captions-position-hover{bottom:35px}.mejs-captions-text,.mejs__captions-text *{padding:0;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(20,20,20,.5);white-space:pre-wrap;-webkit-box-shadow:5px 0 0 rgba(20,20,20,.5),-5px 0 0 rgba(20,20,20,.5);box-shadow:5px 0 0 rgba(20,20,20,.5),-5px 0 0 rgba(20,20,20,.5)}.me-cannotplay{}.me-cannotplay a{color:#fff;font-weight:700}.me-cannotplay span{padding:15px;display:block}.mejs-controls .mejs-loop-off button{background-position:-64px -16px}.mejs-controls .mejs-loop-on button{background-position:-64px 0}.mejs-controls .mejs-backlight-off button{background-position:-80px -16px}.mejs-controls .mejs-backlight-on button{background-position:-80px 0}.mejs-controls .mejs-picturecontrols-button{background-position:-96px 0}.mejs-contextmenu{position:absolute;width:150px;padding:10px;border-radius:4px;top:0;left:0;background:#fff;border:solid 1px #999;z-index:1001}.mejs-contextmenu .mejs-contextmenu-separator{height:1px;font-size:0;margin:5px 6px;background:#333}.mejs-contextmenu .mejs-contextmenu-item{font-family:Helvetica,Arial,serif;font-size:12px;padding:4px 6px;cursor:pointer;color:#333}.mejs-contextmenu .mejs-contextmenu-item:hover{background:#2C7C91;color:#fff}.mejs-controls .mejs-sourcechooser-button{position:relative}.mejs-controls .mejs-sourcechooser-button button{background-position:-128px 0}.mejs-controls .mejs-sourcechooser-button .mejs-sourcechooser-selector{position:absolute;bottom:26px;right:-10px;width:130px;height:100px;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);border:solid 1px transparent;padding:10px;overflow:hidden;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.mejs-controls .mejs-sourcechooser-button .mejs-sourcechooser-selector ul{margin:0;padding:0;display:block;list-style-type:none!important;overflow:hidden}.mejs-controls .mejs-sourcechooser-button .mejs-sourcechooser-selector ul li{margin:0 0 6px;padding:0;list-style-type:none!important;display:block;color:#fff;overflow:hidden}.mejs-controls .mejs-sourcechooser-button .mejs-sourcechooser-selector ul li input{clear:both;float:left;margin:3px 3px 0 5px}.mejs-controls .mejs-sourcechooser-button .mejs-sourcechooser-selector ul li label{width:100px;float:left;padding:4px 0 0;line-height:15px;font-family:Helvetica,Arial,serif;font-size:10px}.mejs-postroll-layer{position:absolute;bottom:0;left:0;width:100%;height:100%;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);z-index:1000;overflow:hidden}.mejs-postroll-layer-content{width:100%;height:100%}.mejs-postroll-close{position:absolute;right:0;top:0;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);color:#fff;padding:4px;z-index:100;cursor:pointer}div.mejs-speed-button{width:46px!important;position:relative}.mejs-controls .mejs-button.mejs-speed-button button{background:transparent;width:36px;font-size:11px;line-height:normal;color:#fff}.mejs-controls .mejs-speed-button .mejs-speed-selector{position:absolute;top:-100px;left:-10px;width:60px;height:100px;background:url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/703c659e4bf563a05c6338a1727e006c.png);background:rgba(50,50,50,.7);border:solid 1px transparent;padding:0;overflow:hidden;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.mejs-controls .mejs-speed-button .mejs-speed-selector ul li label.mejs-speed-selected{color:rgba(33,248,248,1)}.mejs-controls .mejs-speed-button .mejs-speed-selector ul{margin:0;padding:0;display:block;list-style-type:none!important;overflow:hidden}.mejs-controls .mejs-speed-button .mejs-speed-selector ul li{margin:0 0 6px;padding:0 10px;list-style-type:none!important;display:block;color:#fff;overflow:hidden}.mejs-controls .mejs-speed-button .mejs-speed-selector ul li input{clear:both;float:left;margin:3px 3px 0 5px}.mejs-controls .mejs-speed-button .mejs-speed-selector ul li label{width:60px;float:left;padding:4px 0 0;line-height:15px;font-family:Helvetica,Arial,serif;font-size:11px;color:#fff;margin-left:5px;cursor:pointer}.mejs-controls .mejs-speed-button .mejs-speed-selector ul li:hover{background-color:#c8c8c8!important;background-color:rgba(255,255,255,.4)!important}.mejs-controls .mejs-button.mejs-jump-forward-button{background:transparent url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/15e1ac8cbacc2efdf1ac2677de48a253.png) no-repeat 3px 3px}.mejs-controls .mejs-button.mejs-jump-forward-button button{background:transparent;font-size:9px;line-height:normal;color:#fff}.mejs-controls .mejs-button.mejs-skip-back-button{background:transparent url(https://du11hjcvx0uqb.cloudfront.net/dist/webpack-production/cd6dc830eb45b3a5a96bbc936ff54846.png) no-repeat 3px 3px}.mejs-controls .mejs-button.mejs-skip-back-button button{background:transparent;font-size:9px;line-height:normal;color:#fff}</style><style type="text/css">/*
 * Copyright (C) 2014 - present Instructure, Inc.
 *
 * This file is part of Canvas.
 *
 * Canvas is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3 of the License.
 *
 * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* customizations to mediaelementplayer css */

/* good menu widths */
.mejs-sourcechooser-selector {
  width: 160px;
}
.mejs-sourcechooser-selector label {
  width: 160px !important;
}

.mejs-captions-selector {
  width: 105px;
}
.mejs-captions-selector label {
  width: 70px !important;
}

/* Subtitile upload link */
.mejs-captions-selector .upload-track {
  color: white;
  margin: 3px 0 5px 5px;
  float: direction(left);
}

/* "x" button to remove a subtitle */
.mejs-captions-selector a[data-remove] {
  position: absolute;
  top: 0; right: 0;
  color: white;
}


/* style menu items without a radio button */
.mejs-button [role="menu"] {
  padding: 0 !important;
}
 /* compensate for above 0 padding */
 .mejs-button [role="menu"] ul li {
  position: relative;
  padding: 0 10px !important;
}
/* add a hover effect */
.mejs-button [role="menu"] ul li:hover {
  background-color: #c8c8c8 !important;
  background-color: rgba(255, 255, 255, 0.4) !important;
}
.mejs-button [role="menu"] ul li input {
  border: 0;
  clip: rect(0 0 0 0);
  position: absolute;
  overflow: hidden;
  margin: -1px;
  padding: 0;
  width: 1px;
  height: 1px;
}
.mejs-button [role="menu"] ul li label {
  margin-left: 5px;
  cursor: pointer;
}
.mejs-button [role="menu"] label.mejs-selected {
  color: #21f8f8 !important;
}
</style><style type="text/css" data-glamor=""></style></head>

<body class="with-left-side course-menu-expanded padless-content pages primary-nav-transitions context-course_1177926 lato-font-not-loaded-yet show webkit chrome no-touch">

<noscript>
  <div role="alert" class="ic-flash-static ic-flash-error">
    <div class="ic-flash__icon" aria-hidden="true">
      <i class="icon-warning"></i>
    </div>
    <h1>You need to have JavaScript enabled in order to access this site.</h1>
  </div>
</noscript>





<ul id="flash_message_holder"></ul>
<div id="flash_screenreader_holder" role="alert" aria-live="assertive" aria-relevant="additions" class="screenreader-only" aria-atomic="false"></div>

<div id="application" class="ic-app">
  
  <header id="header" class="ic-app-header no-print ">
    <a href="https://canvas.uw.edu/courses/1177926/pages/lesson-10?module_item_id=7889578#content" id="skip_navigation_link">Skip To Content</a>
      <div role="region" class="ic-app-header__main-navigation" aria-label="Global Navigation">
        <div class="ic-app-header__logomark-container">
          <a href="https://canvas.uw.edu/" class="ic-app-header__logomark">
            <span class="screenreader-only">Dashboard</span>
          </a>
        </div>
        <ul id="menu" class="ic-app-header__menu-list">
            <li class="menu-item ic-app-header__menu-list-item ">
              <a id="global_nav_profile_link" href="https://canvas.uw.edu/profile" class="ic-app-header__menu-list-link">
                <div class="menu-item-icon-container" aria-hidden="true">
                  <div class="ic-avatar ">
                    <img src="./Lesson 10_files/mSs2TjTESYscSzrackhgoJvAT79xbNchamHPrSec" alt="Clayton Wong">
                  </div>
                </div>
                <div class="menu-item__text">
                  Account
                </div>
              </a>
            </li>
          <li class="ic-app-header__menu-list-item ">
            <a id="global_nav_dashboard_link" href="https://canvas.uw.edu/" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                  <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--dashboard" version="1.1" x="0" y="0" viewBox="0 0 280 200" enable-background="new 0 0 280 200" xml:space="preserve"><path d="M273.09,180.75H197.47V164.47h62.62A122.16,122.16,0,1,0,17.85,142a124,124,0,0,0,2,22.51H90.18v16.29H6.89l-1.5-6.22A138.51,138.51,0,0,1,1.57,142C1.57,65.64,63.67,3.53,140,3.53S278.43,65.64,278.43,142a137.67,137.67,0,0,1-3.84,32.57ZM66.49,87.63,50.24,71.38,61.75,59.86,78,76.12Zm147,0L202,76.12l16.25-16.25,11.51,11.51ZM131.85,53.82v-23h16.29v23Zm15.63,142.3a31.71,31.71,0,0,1-28-16.81c-6.4-12.08-15.73-72.29-17.54-84.25a8.15,8.15,0,0,1,13.58-7.2c8.88,8.21,53.48,49.72,59.88,61.81a31.61,31.61,0,0,1-27.9,46.45ZM121.81,116.2c4.17,24.56,9.23,50.21,12,55.49A15.35,15.35,0,1,0,161,157.3C158.18,152,139.79,133.44,121.81,116.2Z"></path></svg>

              </div>
              <div class="menu-item__text">Dashboard</div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ic-app-header__menu-list-item--active">
            <a id="global_nav_courses_link" href="https://canvas.uw.edu/courses" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--courses" version="1.1" x="0" y="0" viewBox="0 0 280 259" enable-background="new 0 0 280 259" xml:space="preserve"><path d="M73.31,198c-11.93,0-22.22,8-24,18.73a26.67,26.67,0,0,0-.3,3.63v.3a22,22,0,0,0,5.44,14.65,22.47,22.47,0,0,0,17.22,8H200V228.19h-134V213.08H200V198Zm21-105.74h90.64V62H94.3ZM79.19,107.34V46.92H200v60.42Zm7.55,30.21V122.45H192.49v15.11ZM71.65,16.71A22.72,22.72,0,0,0,49,39.36V190.88a41.12,41.12,0,0,1,24.32-8h157V16.71ZM33.88,39.36A37.78,37.78,0,0,1,71.65,1.6H245.36V198H215.15v45.32h22.66V258.4H71.65a37.85,37.85,0,0,1-37.76-37.76Z"></path></svg>

              </div>
              <div class="menu-item__text">
                Courses
              </div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ">
            <a id="global_nav_calendar_link" href="https://canvas.uw.edu/calendar" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--calendar" version="1.1" x="0" y="0" viewBox="0 0 280 280" enable-background="new 0 0 280 280" xml:space="preserve"><path d="M197.07,213.38h16.31V197.07H197.07Zm-16.31,16.31V180.76h48.92v48.92Zm-48.92-16.31h16.31V197.07H131.85Zm-16.31,16.31V180.76h48.92v48.92ZM66.62,213.38H82.93V197.07H66.62ZM50.32,229.68V180.76H99.24v48.92Zm146.75-81.53h16.31V131.85H197.07Zm-16.31,16.31V115.54h48.92v48.92Zm-48.92-16.31h16.31V131.85H131.85Zm-16.31,16.31V115.54h48.92v48.92ZM66.62,148.15H82.93V131.85H66.62ZM50.32,164.46V115.54H99.24v48.92ZM34,262.29H246V82.93H34ZM246,66.62V42.16A8.17,8.17,0,0,0,237.84,34H213.38v8.15a8.15,8.15,0,1,1-16.31,0V34H82.93v8.15a8.15,8.15,0,0,1-16.31,0V34H42.16A8.17,8.17,0,0,0,34,42.16V66.62Zm-8.15-48.92a24.49,24.49,0,0,1,24.46,24.46V278.6H17.71V42.16A24.49,24.49,0,0,1,42.16,17.71H66.62V9.55a8.15,8.15,0,0,1,16.31,0v8.15H197.07V9.55a8.15,8.15,0,1,1,16.31,0v8.15Z"></path></svg>

              </div>
              <div class="menu-item__text">
                Calendar
              </div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ">
            <a id="global_nav_conversations_link" href="https://canvas.uw.edu/conversations" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--inbox" version="1.1" x="0" y="0" viewBox="0 0 280 280" enable-background="new 0 0 280 280" xml:space="preserve"><path d="M91.72,120.75h96.56V104.65H91.72Zm0,48.28h80.47V152.94H91.72Zm0-96.56h80.47V56.37H91.72Zm160.94,34.88H228.52V10.78h-177v96.56H27.34A24.17,24.17,0,0,0,3.2,131.48V244.14a24.17,24.17,0,0,0,24.14,24.14H252.66a24.17,24.17,0,0,0,24.14-24.14V131.48A24.17,24.17,0,0,0,252.66,107.34Zm0,16.09a8.06,8.06,0,0,1,8,8v51.77l-32.19,19.31V123.44ZM67.58,203.91v-177H212.42v177ZM27.34,123.44H51.48v79.13L19.29,183.26V131.48A8.06,8.06,0,0,1,27.34,123.44ZM252.66,252.19H27.34a8.06,8.06,0,0,1-8-8V202l30,18H230.75l30-18v42.12A8.06,8.06,0,0,1,252.66,252.19Z"></path></svg>

                <span class="menu-item__badge" style="display: none">0</span>
              </div>
              <div class="menu-item__text">
                Inbox
              </div>
            </a>
          </li>
            


          <li class="ic-app-header__menu-list-item">
           <a id="global_nav_help_link" class="ic-app-header__menu-list-link" data-track-category="help system" data-track-label="help button" href="http://help.instructure.com/">
              <div class="menu-item-icon-container" role="presentation">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg menu-item__icon svg-icon-help" version="1.1" x="0" y="0" viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" fill="currentColor"><path d="M100,127.88A11.15,11.15,0,1,0,111.16,139,11.16,11.16,0,0,0,100,127.88Zm8.82-88.08a33.19,33.19,0,0,1,23.5,23.5,33.54,33.54,0,0,1-24,41.23,3.4,3.4,0,0,0-2.74,3.15v9.06H94.42v-9.06a14.57,14.57,0,0,1,11.13-14,22.43,22.43,0,0,0,13.66-10.27,22.73,22.73,0,0,0,2.31-17.37A21.92,21.92,0,0,0,106,50.59a22.67,22.67,0,0,0-19.68,3.88,22.18,22.18,0,0,0-8.65,17.64H66.54a33.25,33.25,0,0,1,13-26.47A33.72,33.72,0,0,1,108.82,39.8ZM100,5.2A94.8,94.8,0,1,0,194.8,100,94.91,94.91,0,0,0,100,5.2m0,178.45A83.65,83.65,0,1,1,183.65,100,83.73,83.73,0,0,1,100,183.65" transform="translate(-5.2 -5.2)"></path></svg>

              </div>
              <div class="menu-item__text">
                Help
              </div>
</a>          </li>
        </ul>
      </div>
      <div class="ic-app-header__secondary-navigation">
        <ul class="ic-app-header__menu-list">
          <li class="menu-item ic-app-header__menu-list-item">
            <button id="primaryNavToggle" class="ic-app-header__menu-list-link ic-app-header__menu-list-link--nav-toggle" aria-label="Expand global navigation
                " title="Expand global navigation
                ">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--navtoggle" version="1.1" x="0" y="0" width="40" height="32" viewBox="0 0 40 32" xml:space="preserve">
  <path d="M39.5,30.28V2.48H37.18v27.8Zm-4.93-13.9L22.17,4,20.53,5.61l9.61,9.61H.5v2.31H30.14l-9.61,9.61,1.64,1.64Z"></path>
</svg>

              </div>
            </button>
          </li>
        </ul>
      </div>
    <div id="global_nav_tray_container"><noscript data-reactid=".0"></noscript></div>
  </header>


  <div id="instructure_ajax_error_box">
    <div style="text-align: right; background-color: #fff;"><a href="https://canvas.uw.edu/courses/1177926/pages/lesson-10?module_item_id=7889578#" class="close_instructure_ajax_error_box_link">Close</a></div>
    <iframe id="instructure_ajax_error_result" src="./Lesson 10_files/saved_resource.html" style="border: 0;" title="Error"></iframe>
  </div>

  

  <div id="wrapper" class="ic-Layout-wrapper">
      <div class="ic-app-nav-toggle-and-crumbs no-print">
          <button type="button" id="courseMenuToggle" class="Button Button--link ic-app-course-nav-toggle" aria-live="polite" aria-label="Hide Courses Navigation Menu" title="Hide Courses Navigation Menu">
            <i class="icon-hamburger" aria-hidden="true"></i>
          </button>
          <div class="ic-app-crumbs">
        <nav id="breadcrumbs" role="navigation" aria-label="breadcrumbs"><ul><li class="home"><a href="https://canvas.uw.edu/"><span class="ellipsible">      <i class="icon-home" title="My Dashboard">
        <span class="screenreader-only">My Dashboard</span>
      </i>
</span></a></li><li><a href="https://canvas.uw.edu/courses/1177926"><span class="ellipsible">CPROGRM 711 A</span></a></li><li><a href="https://canvas.uw.edu/courses/1177926/pages"><span class="ellipsible">Pages</span></a></li><li><span class="ellipsible">Lesson 10</span></li></ul></nav>
        </div>
      </div>
    <div id="main" class="ic-Layout-columns">
        <div class="ic-Layout-watermark"></div>
        <div id="left-side" class="ic-app-course-menu list-view" style="display: block">
              <span id="section-tabs-header-subtitle" class="ellipsis">Winter 2018</span>
            <nav role="navigation" aria-label="Courses Navigation Menu"><ul id="section-tabs"><li class="section"><a href="https://canvas.uw.edu/courses/1177926" title="Home" class="home" tabindex="0">Home</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/announcements" title="Announcements" class="announcements" tabindex="0">Announcements</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/modules" title="Modules" class="modules" tabindex="0">Modules</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/discussion_topics" title="Discussions" class="discussions" tabindex="0">Discussions</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/grades" title="Grades" class="grades" tabindex="0">Grades</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/users" title="People" class="people" tabindex="0">People</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/external_tools/12299" title="UW Libraries" class="context_external_tool_12299" tabindex="0">UW Libraries</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/external_tools/57145" title="Info &amp; Help" class="context_external_tool_57145" tabindex="0">Info &amp; Help</a></li></ul></nav>
        </div>
      <div id="not_right_side" class="ic-app-main-content">
        <div id="content-wrapper" class="ic-Layout-contentWrapper">
            

          <div id="content" class="ic-Layout-contentMain" role="main">
            

  

<div id="wiki_page_show">
<div class="header-bar-outer-container">
  <div class="header-bar-container sticky-toolbar sticky" data-sticky="">
    <div class="header-bar flex-container">
      <div class="header-bar-left header-left-flex">
        
          
        
      </div>
      <div class="header-bar-right header-right-flex">
        
          
          
            
          
        
        
          
        
        
      </div>
    </div>
    <div class="page-changed-alert" role="alert" aria-atomic="true" aria-live="polite"></div>
  </div>
</div>


<div class="show-content user_content clearfix enhanced">
  <h1 class="page-title">Lesson 10</h1>
  
    
  
  
    <h2><span><img src="./Lesson 10_files/L10.png" alt="L10.png" width="50" height="50" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384332" data-api-returntype="File" style="max-width: 962px;">&nbsp;C++ and Polymorphism</span></h2>
<div class="keytermBox" style="background-color: #F3F3E9;">
<h6>Key Terms</h6>
<ul>
<li>early binding</li>
<li>late binding</li>
<li>interface</li>
<li>implementation</li>
<li>non-virtual function</li>
<li>pure virtual function</li>
<li>abstract class</li>
<li>concrete class</li>
<li>static binding (or compile time binding)</li>
<li>dynamic binding (or run time binding)</li>
<li>polymorphic</li>
<li>vtable (vtbl)</li>
<li>vpointer (vptr)</li>
<li>virtual base class</li>
</ul>
</div>
<h3>Inheritance and Runtime Polymorphism in C++</h3>
<h4>Getting Acquainted</h4>
<p>One of the pillars of the object oriented programming is the concept of polymorphism. The idea behind polymorphic behavior is to have the same general type of action accomplished in different ways by different types of objects. C++ permits the programmer to call the same member function on different but related objects to achieve different but related actions.</p>
<p>The polymorphic approach also helps to reduce complexity from both the designer's and the user's perspective by permitting a common interface to specify a more general class of actions. As we move toward generic programs, we will learn to abstract the functionality of the program from the underlying data types. Different classes, related through inheritance, respond differently, yet appropriately, to the same message with different member function calls. Once again, such a design philosophy provides us reusable code. Reusable code allows us to extend a class through inheritance and have the new object respond to existing messages.</p>
<p>A key element of polymorphism lies in the process of binding or connecting a function call with the function body. In C++, we establish such a link either at compile time, which we call <span class="keyterm">early binding</span>, or at runtime, which we call <span class="keyterm">late binding</span>.</p>
<p>We implement early binding through coding function calls in such a way that the exact function being called is known at compile time. Such an approach allows us to achieve greater execution speed and runtime efficiency through code optimization. Late binding is when the exact function being called is not known until the program runs. In C we could accomplish this using pointers to functions. In C++, late binding is implemented with virtual functions.</p>
<h3>The Concept of Inheritance</h3>
<p>In our last two lessons, we've seen that inheritance introduces the concept of a collection of classes with many shared characteristics. People often think that this is what C++ is all about. The idea of shared characteristics or, more specifically, a common interface is consistent with the concept of polymorphism. Polymorphism focuses on both inheritance and abstraction.</p>
<p>When we think about inheritance, we must consider what is being inherited. When we look at the public interface of a class, we see it comprises two separate parts. We have the <span class="keyterm">interface</span> and the <span class="keyterm">implementation</span>(s). If we want the parent class interface to be overridden, then we should use virtual functions. In contrast, to prohibit overriding, we should use <span class="keyterm">non-virtual functions</span>. If we want to propagate the interface, then we should choose <span class="keyterm">pure virtual functions</span>.</p>
<h3>Abstract Base Classes and Virtual Functions</h3>
<p>Late binding polymorphism in C++ is implemented through two ideas, abstract base classes and virtual functions. Let's examine each of these in turn.</p>
<h4>Abstract Base Classes: A First Look</h4>
<p>Generally a class is designed to have instances. However, there are cases in which it is useful to design classes that are never intended to have instances. Such classes are called <span class="keyterm">abstract classes</span>. They cannot have instances—there are no objects of the abstract class type. The class Vehicles can serve as a base from which to derive automobiles, boats, aircraft, or spaceships, yet, as we've seen, a Vehicle does not exist in a concrete sense.</p>
<p>We can, however, have pointers of an abstract class type. Such pointers can be used to polymorphically manipulate derived class instances. The sole purpose of such classes is to provide a common public interface to the class hierarchy and as the basis from which to derive other classes. These are referred to as <span class="keyterm">abstract base classes</span> (<span class="keyterm">ABC</span>). We use them to provide a common subset of properties to a complete collection of related classes. Classes derived from an ABC (and instantiated) are thus called <span class="keyterm">concrete classes</span>.</p>
<h4>Virtual Functions: A First Look</h4>
<p>A virtual function is a mechanism for inheriting a functional interface and default implementation for such a function. A virtual function must be declared and defined in a parent class. Its declaration is preceded by the keyword virtual and its name can only be used once in the parent class. We can't overload a virtual function, and only class member functions can be declared virtual. The syntax for such a declaration takes two forms.</p>
<ul>
<li>virtual function:<br><code>virtual returnType functionName(args ) <br> { function body }</code>
</li>
<li>pure virtual function:<br><code>virtual returnType functionName(args) = 0;</code>
</li>
</ul>
<p>A function is virtual if it is declared virtual, or if there is a base class function with the same name and signature that has been declared virtual. Any or all class member functions (except the constructor) can be declared virtual. Although a virtual function does not have to be explicitly so annotated in a derived class, it's good practice to do so. Anything we can put into our code to simplify, clarify, and communicate to others should be done. Comments and annotation don't generate object code—they're free.</p>
<h4>Regular Virtual Functions</h4>
<p>Let's look at this first example and see what we're really getting with all this virtual stuff. In the base class (<code>Fruit</code>), we've declared the function<code> identify()</code> to be virtual. It now becomes virtual throughout the class hierarchy. Next, if we use a base class pointer to <code>Fruit</code>, initialized to point to a derived classinstance <code>Apple</code> and invoke the <code>identify()</code> member function, we get the function associated with the Apple class. Had <code>identify()</code> not been virtual, we would have gotten the one from <code>Fruit</code>. We've gotten the function associated with the type of the <span class="bold">object</span>, not the type of the <span class="bold">pointer</span>. The virtual mechanism is at work.</p>
<p>Such an example may be interesting for picking fruit. In a larger sense, the virtual mechanism enables us to use a public base class pointer, instantiated to the address of any of the members of the derived class, and have the appropriate behavior invoked. In the Example below, we'll revisit our <code>Fruit</code> hierarchy.</p>
<pre>#include "TestHarness.h"<br><br>// Classes Derivation - Single Inheritance Example<br>// Simple Inheritance - Virtual Functions<br><br>#include &lt;memory&gt;<br><br>class Fruit<br>{<br>public:<br> Fruit() : stem(1), seeds(4)<br> {<br> }<br><br> virtual ~Fruit() = default;<br><br> virtual std::string identify() const<br> {<br> return "Fruit";<br> }<br><br> int getStem() const<br> {<br> return stem;<br> }<br><br>private:<br> int stem;<br> int seeds;<br>};<br><br>class Apple : public Fruit<br>{<br>public:<br> Apple() : skin(2)<br> {<br> }<br><br> std::string identify() const override<br> {<br> return "Apple";<br> }<br><br> int getSkin() const<br> {<br> return skin;<br> }<br><br>private:<br> int skin;<br>};<br><br>TEST(polymorphism, Lesson10)<br>{<br> auto fp = std::make_unique&lt;Apple&gt;();<br> auto ap = std::make_unique&lt;Apple&gt;();<br><br> // via polymorphism - call Apple's implementation of identify<br> CHECK_EQUAL("Apple", fp-&gt;identify());<br> CHECK_EQUAL(1, fp-&gt;getStem());<br><br> // fp-&gt;getSkin(); // error - skin not a member of fruit<br> CHECK_EQUAL("Apple", ap-&gt;identify());<br><br> auto fp1 = std::make_unique&lt;Fruit&gt;();<br><br> // via polymorphism - call Fruit's implementation of identify<br> CHECK_EQUAL("Fruit", fp1-&gt;identify());<br>}</pre>
<p>The code for a regular virtual function must be supplied in the parent class. A derived class may optionally replace the code provided by the base class in the virtual function. This is called overriding the virtual function.</p>
<h4>Pure Virtual Functions</h4>
<p>A pure virtual function is declared as:</p>
<pre>class Fruit
{
    ...
    virtual bool hasSeeds() const = 0;
};       </pre>
<p>Where = 0 denotes the function is pure virtual. Pure virtual functions mmust be overridden in the derived class. Regular virtual functions may be overridden in a derived class.</p>
<p>A derived class can choose to override the definition by providing its own implementation; however, it cannot redefine the return type. We'll see in the advanced course that there are some exceptions.</p>
<p>If the re-declaration in a derived class does not match exactly, the function is not virtual for that class. The derived class name then hides the virtual function. In most situations hiding a virtual function is either a coding error, or a design error. We can still have a virtual function in a subsequently derived class. It is an error if the derived and base class functions differ only in return type.</p>
<pre>#include "TestHarness.h"<br><br>#include &lt;memory&gt;<br><br>#include &lt;string&gt;<br><br>class Fruit<br>{<br>public:<br> explicit Fruit(int stem = 1) : myStem(stem)<br> {<br> }<br><br> virtual ~Fruit() = default;<br><br> virtual std::string identify() const<br> {<br> return "Fruit";<br> }<br><br> int getStem() const<br> {<br> return myStem;<br> }<br><br>private:<br> int myStem;<br>};<br><br>class Apple : public Fruit<br>{<br>public:<br> explicit Apple(int skin = 2, int stem = 1)<br> : Fruit(stem),<br> mySkin(2)<br> {<br> }<br><br> std::string identify() const override<br> {<br> return "Apple";<br> }<br><br>private:<br> int mySkin;<br>};<br><br>class CrabApple : public Apple<br>{<br>public:<br> CrabApple()<br> : Apple(3, 4)<br> {<br> }<br><br> std::string identify() const override<br> {<br> return "CrabApple";<br> }<br>};<br><br>TEST(polymorphism2, Lesson10)<br>{<br> // Use base class pointer to point<br> // to a derived class objects<br> auto fp = std::make_unique&lt;Apple&gt;();<br> auto cap = std::make_unique&lt;CrabApple&gt;();<br><br> CHECK_EQUAL("Apple", fp-&gt;identify());<br> CHECK_EQUAL(1, fp-&gt;getStem());<br> CHECK_EQUAL("CrabApple", cap-&gt;identify());<br><br> // Fruit tracks the number of stems. Note how CrapApples<br> // constructor passes the number of stems to Fruit<br> CHECK_EQUAL(4, cap-&gt;getStem());<br>}</pre>
<h3>Virtual Functions in Detail</h3>
<h4>Putting It Together</h4>
<p>The purpose of declaring a virtual function is to permit the derived class to inherit the functional interface. We may also decide to provide a default implementation from in the parent class. If the virtual function is pure virtual we don't have to provide a default implementation in the base class. A derived class can override the definition by providing its own implementation. Observe that we are overriding, not overloading. We are changing the body, not the signature of the function. We are permitted to both override and overload a function within the same class.</p>
<p>Such a capability permits multiple functions to be called through a common interface. The virtual mechanism can be overridden by explicit qualification with the scope operator. Our class hierarchy now appears as shown below. Polymorphism gives us a uniform function call interface to the hierarchy.</p>
<img src="./Lesson 10_files/c++711s10fig10-01.gif" alt="class hierarchy" width="305" height="248" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384256" data-api-returntype="File" style="max-width: 962px;"><br>
<p>When a function in a class is declared virtual, the keyword <code>virtual</code> tells the compiler not to perform early binding and to install mechanisms to perform late binding. The compiler responds by creating a table of function pointers and installing a data member to the class to point to the table. This table is called the <span class="keyterm">vtable</span> or <span class="keyterm">vtbl</span>. The <span class="italics">vtbl</span> contains pointers to all functions declared virtual within the class and the derived classes. It's typically implemented as an array of pointers to functions although some compilers will use a linked list. These are now non-member functions—not inlined. Each class within a hierarchy gets its own vtable and the table contains only pointers to virtual functions. There is only one virtual table per class.</p>
<p>When virtual functions are used, memory must be set aside for a vtable in each class that contains virtual functions. The size of the vtable will be proportional to the number of virtual functions in the class. Generally, abstract classes have no vtable. Since vtables can only be referenced by an object and abstract classes are not instantiated, vtables are unnecessary.</p>
<img src="./Lesson 10_files/c++711s10fig10-02.gif" alt="Base class and Vtable" width="439" height="133" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384311" data-api-returntype="File" style="max-width: 962px;"><br>
<p>A data member, called a <span class="keyterm">vpointer</span> or <span class="keyterm">vptr</span>, is (in most cases) placed as the first element in the object in memory and initialized to the starting address of the vtable. The initialization is done in the constructor (or a compiler generated default) using code the compiler has added. Consequently, we cannot make a virtual function call before the vpointer is initialized. Each object of a class containing virtual functions must have this extra pointer. So now each object using virtual functions has a this pointer and a vpointer.</p>
<p>A function call through the base class pointer, therefore, knows the type of the object for which the call is being made. From here, the function call code follows the vptr to the vtbl. This is a simple operation; the compiler knows where the vptr is in the object—after all, it put it there. Thus, we have an offset operation from the start of the object followed by an indirection into the vtbl. To find the pointer in the vtbl to the function being called, we index into the array—offset into the vtbl—to invoke the function located at the target address. This is generally an efficient operation.</p>
<p class="title"><span class="bold">Base Class, Derived Class, and Vtable</span></p>
<img src="./Lesson 10_files/c++711s10fig10-03.gif" alt="base class, derived class, and Vtable" width="483" height="342" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384307" data-api-returntype="File" style="max-width: 962px;"><br>
<p>In the second figure, note that if <code>k()</code> had not been redefined, the address in the vtable would be that of the base class version.</p>
<h4>Invoking a Virtual Function</h4>
<p>A virtual function is invoked through a public base class reference or pointer. The binding is typically dynamic at runtime. Virtual functions are not inlined. As we know, inlining tells the compiler to replace the function call with the body of the function. Since the whole intent of polymorphism, however, is to defer such a decision until runtime, the compiler will be long gone. Inlining is generally something we give up when we use virtual functions.</p>
<p>In the case of virtual functions, the function to be invoked is determined by the class type of the actual object addressed by the reference or pointer. For non-virtual functions, it's determined by the class type of the pointer or reference.</p>
<h4>Access Protection</h4>
<p>The access level of a virtual function is determined, indirectly, by the class type of the pointer through which the virtual function is invoked, not by the class in which it's defined.</p>
<pre>&nbsp;&nbsp;&nbsp; A
&nbsp;&nbsp;&nbsp; B : public A
&nbsp;&nbsp;&nbsp; C : public B
&nbsp;&nbsp;&nbsp; D : public C
&nbsp;&nbsp;&nbsp; E : public D</pre>
declare
<p>public virtual function <code>f1()</code> in <code>A</code></p>
<p>protected virtual function <code>f1()</code> in <code>B</code></p>
<p>private virtual function <code>f1()</code> in <code>C</code></p>
<p>public virtual function <code>f1()</code> in <code>D</code></p>
<p>define</p>
<code>A* a = new B; </code>
<p><code>a = new C; </code></p>
<p><code>C* c = new D; </code></p>
<p>write</p>
<p style="margin-top: 0px; margin-bottom: 0px;"><code>a-&gt;f1(); // f1 ()</code> is accessible through <code>*a as a *B</code></p>
<p style="margin-top: 0px;"><code>f1() </code>was declared in the public portion of <code>A</code></p>
<p style="margin-top: 0px; margin-bottom: 0px;"><code>a-&gt;f1(); // f1 ()</code> is accessible through <code>*a as a *C</code></p>
<p style="margin-top: 0px;"><code>f1() </code>was declared in the public portion of <code>A</code></p>
<p style="margin-top: 0px; margin-bottom: 0px;"><code>c-&gt;f1(); // f1 ()</code> not accessible through <code>*c as a *D</code></p>
<p style="margin-top: 0px;"><code>f1() </code>was declared in the private portion of <code>C</code></p>
<h3>Virtual Destructors</h3>
<p>Consider what happens when we use a base class pointer to refer to a derived class instance.</p>
<p class="title"><span class="bold">Example 10.4</span></p>
<pre>// Classes Derivation - Single Inheritance Example
// Simple Inheritance - Virtual Destructors

class A
{
public:
    A()
    {
    }

    ~A()
    {
        std::cout &lt;&lt; "Destroying A" &lt;&lt; std::endl;
    }

    virtual std::string identify() const
    {
        return "A";
    }
};

class B: public A
{
public:
    B()
    {
    }

    ~B()
    {
        std::cout &lt;&lt; "Destroying B" &lt;&lt; std::endl;
    }

    std::string identify() const
    {
        return "B";
    }
};

TEST(VirtualDestructures, Class)
{
    A* a = new B;
    CHECK_EQUAL("B", a-&gt;identify());

    // ERROR: will print Destroying A
    // B's destructor is not called!
    // What we want is for the destructors to be chained. First we want B::~B to be called, then we want A::~A called
    delete a;
}</pre>
<p>Observe that the expression <code>delete a</code> only invokes the class <code>A</code> destructor with the result that only the memory associated with the <code>A</code> part of the <code>B</code> object is deinitialized. We want the destructors for both classes to be invoked. Since <code>*a</code> is a base class pointer, only the <code>A</code> destructor is invoked.</p>
<p>To see why this happens, recall that with non-virtual functions, the function invoked is determined by the type of the pointer to the object, not by the type of the object. Here we are using an <code>A</code> type pointer; the destructor is not virtual, so we get the function associated with <code>A</code>—the class <code>A</code> destructor. To fix the problem, we simply declare the base class destructor to be virtual. The syntax for such a declaration is as we'd expect:</p>
<pre>virtual ~class ClassName() { destructor body }</pre>
<p>Now if we repeat the previous example with the base class destructor declared virtual, we'll get both destructors invoked.</p>
<p>As with a virtual function, if a base class declares a destructor virtual, every destructor in the derivation hierarchy is virtual. Specifying a base class destructor to be virtual guarantees that the appropriate destructors will be invoked whenever delete is applied to the object at the end of a base class pointer. A general rule of thumb suggests that if a class is abstract, by virtue of having one or more virtual functions, the destructor should always be declared virtual.</p>
<p>If the class is not abstract, there's no need to expend the extra memory for the vtable and all of the associated pointers. As with non-virtual destructors, the invocation of a chain of virtual destructors begins with the most derived class and unwinds up the derivation chain to the base.</p>
<h3>Abstract Base Classes, Virtual Functions, and Pure Virtual Functions</h3>
<h4>Virtual Functions Again</h4>
<p>Let's begin the discussion of pure virtual functions by looking at virtual functions. Recall that a virtual function must be defined when it's declared. Such a definition may not always be appropriate. Consider a potential problem with a simple virtual function. Let's define the following class hierarchy:</p>
<pre>class BaseClass
{
public:
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;provide a default definition of&nbsp; dFunct()
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const
    {
        return 12;
    }
};

class DerivedClass1 : public BaseClass
{
public:
    //&nbsp;redefine default definition of dFunct()
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const
    {
        return 3;
    }
};

class DerivedClass2 : public BaseClass
{
    //&nbsp;accept default definition of dFunct()
};

class DerivedClass3 : public BaseClass
{
    //&nbsp;accept default definition of dFunct()
};</pre>
<p>The problem here is that there is no reasonable default behavior for derived classes. If, through error or oversight, <code>dFunct()</code> is not redefined in&nbsp;<code>DerivedClass1, DerivedClass2, or DerivedClass3</code>, the potential dire consequences may turn real. There are several possible solutions to the problem. One possibility is to force each derived class to define the function. We do this by declaring the original function to be pure virtual:</p>
<pre>class BaseClass
{
public:
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const = 0;
};

class DerivedClass1 : public BaseClass
{
public:
    //&nbsp;redefine default definition of dFunct()
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const
    {
        return 3;
    }
};

class DerivedClass2 : public BaseClass
{
public:
    //&nbsp;all subclasses must override a pure virtual function
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const
    {
        return 6;
    }
};

class DerivedClass3 : public BaseClass
{
public:
    //&nbsp;all subclasses must override a pure virtual function
&nbsp;&nbsp;&nbsp;&nbsp;virtual int dFunct() const
    {
        return 22;
    }
};</pre>
<p>Such an action ensures that the derived class will provide a definition.</p>
<p>Alternately, we could provide a default definition in a protected area of the parent class. The derived class could access that function by simply writing</p>
<pre>BaseClass::dFunction()    // default definition </pre>
<p>Such a function must be non-virtual or the problem is just repeated.</p>
<h4>Pure Virtual Functions</h4>
<p>The purpose of declaring a pure virtual function is to have the derived class only inherit the functional interface of the class. If a virtual function is declared pure, there is no need to supply an implementation.</p>
<p>The basic syntax for declaring a pure virtual function is as follows:</p>
<pre>virtual returnType functionName(argsi) = 0; </pre>
<p>When a function is declared pure, there is no address to put into the vtable. Remember, the name of a function, like an array, is its address—we just set that address to 0. The 0 keys the compiler that no instances of this class can be created—no vtable, no instances. Before we can create instances of any classes further down the derivation chain, a definition for the function body must be provided. The first class to define such a body may have instances. That definition serves as the default in any subsequent derivations.</p>
<p>In Example below, the function <code>identify() </code>is declared pure in the base class. Thus, we cannot have instances of that class. The first derived class, class <code>B</code>, provides a definition and, thus, may have instances. Notice that class <code>C</code> chooses to override the definition.</p>
<pre>// Classes Derivation - Single Inheritance Example
// Simple Inheritance - Pure Virtual Functions

class A
{
public:
    virtual std::string identify() const = 0;
};

class B: public A
{
public:
    std::string identify() const
    {
        return "B";
    }
};

class C: public B
{
public:
    std::string identify() const
    {
        return "C";
    }

private:
    int aValue;
};

TEST(PureVirtualFunctions, Class)
{
    // error - can instantiate a class with pure virtual functions
    // A a;

    B* b = new B;
    CHECK_EQUAL("B", b-&gt;identify());
    delete b;

    b = new C;
    CHECK_EQUAL("C", b-&gt;identify());
    delete b;
}</pre>
<h3>Restrictions on Pure Virtual Functions</h3>
<p>A class with one or more pure virtual functions, including those that are inherited,</p>
<ul>
<li>can only be used as a base class;</li>
<li>can be used as a pointer or reference type.</li>
<li>cannot have instances;</li>
<li>cannot be used as an argument type, return type, or type for explicit conversion; and</li>
</ul>
<h4>Rules for Virtual Functions</h4>
<ul>
<li>Virtual functions called from within a constructor use the local version.</li>
<li>The first class in a derivation hierarchy that declares a virtual function must provide a definition or must declare the virtual function to be pure.</li>
<li>If a definition is provided, the definition serves as the default instance in subsequent derivations.</li>
<li>If the virtual function is declared pure, a subsequently derived class must provide a definition to be able to have instances—or inherit the pure virtual function and have no instances.</li>
</ul>
<h4>Abstract Base Classes</h4>
<p>A class with one or more pure virtual functions is called an <span class="italics">abstract class.</span> An abstract class is not intended to be instantiated and<span class="bold"> cannot</span> be instantiated. Their sole purpose, through a set of pure virtual functions, is to specify the interface to the class hierarchy. They decouple interfaces from the actual implementation. A typical implementation includes no data members and no constructor—no need for one, no instances.</p>
<p>The cost of using abstract base classes is that every function call is virtual; that is, it requires an additional level of indirection. Objects derived from an abstract class must contain additional information in the form of a virtual pointer into the vtbl or virtual table. Such information is used at runtime to determine which virtual function is to be invoked. Inlining is not effective. Inlining requires access to implementation details; Abstract classes and other such classes are designed to preclude such access.</p>
<p>If a virtual destructor is declared pure, we must provide a definition. In C++, the destructor for the most derived class is called first, and then the destructors for each derived class are called subsequently. The compiler will generate a call to the ABC destructor even though the class is abstract and so simply defines an empty body.</p>
<h3>Object Slicing</h3>
<p>We must exercise caution when treating objects polymorphically. There is a distinct difference between passing objects by value and passing them by reference:</p>
<pre>// Classes Derivation - Single Inheritance Example
// Simple Inheritance - Object Slicing

class Base
{
public:
    Base (int aValue = 0)
        : bVal(aValue)
    {
    }

    virtual int f() const
    {
        return bVal;
    }

private:
    int bVal;
};

class Derived : public Base
{
public:
    Derived(int aVal0=0,int aVal1 = 0)
        : Base(aVal0),
        dVal(aVal1)
    {
    }

    int f() const
    {
        return Base::f() + dVal;
    }

private:
    int dVal;
};

int callV(Base b1)
{
    return b1.f();
}

int callR(const Base&amp; b1)
{
    return b1.f();
}

TEST(ObjectSlicing, Class)
{
    Base b(10);
    Derived d(10, 47);

    CHECK_EQUAL(10, callV(b));
    CHECK_EQUAL(10, callV(d));
    CHECK_EQUAL(10, callR(b));
    CHECK_EQUAL(57, callR(d));
}</pre>
<p>Notice that, in this example, the function <code>callV()</code> accepts only a <code>Base</code>type object. When invoked, it will cause an object of size <code>Base</code> to be pushed onto the stack. The compiler accepts the argument of type <code>Derived</code> then pushes only the <code>Base</code> portion onto the stack. This is not the behavior we want. Thus, always pass base classes to functions by reference, const reference, or pointer. Prefer reference when the function will modify the class and const reference when the function only need read data from the class.</p>
<h3>Virtual Base Classes</h3>
<h4>The Need for Virtual Base Classes</h4>
<p>Let's examine a different portion of the fruit hierarchy. A nectarine is a Fruit developed by crossing a Peach and a Plum, each of which inherits from Fruit:</p>
<p><img src="./Lesson 10_files/c++711s10fig10-04.gif" alt="inheritance from fruit" width="157" height="97" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384314" data-api-returntype="File" style="max-width: 962px;"></p>
<p>If Fruit has a data member <code>stem = 1;</code>, then Plum and Peach will each inherit <code>stem</code>. Nectarine will now inherit a stem from each and now has two copies of the data member.</p>
<p><span class="title"><span class="bold">A Nectarine with Two Stems?</span></span></p>
<p><img src="./Lesson 10_files/c++711s10fig10-05.gif" alt="a nectarine with two stems?" width="217" height="157" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384291" data-api-returntype="File" style="max-width: 962px;"></p>
<p>This is not a natural situation unless you happen to have gotten the Nectarine from Chernobyl. In any event, this is something we'd generally like to avoid. Theoretically, we could resolve the dilemma with the scope operator:</p>
<pre>Plum::stem;
Peach::stem; </pre>
<p>This does not represent the real world either. (A nectarine simply does not have two stems.)</p>
<p>We solve the problem by declaring Fruit as a <span class="keyterm">virtual base class</span>. Such a declaration says there is only a single copy of the base class in the derivation hierarchy. This means that there is only a single copy of all inherited members. Subsequent derivations point to the shared members. This involves serious pointer magic—we're dealing with base classes implemented as pointers to objects--and is highly compiler dependent.</p>
<p>The syntax for a including a virtual base class qualification in a class derivation is as follows:</p>
<pre>class DerivedClassName: virtual specification BaseClassName</pre>
<p><code>DerivedClassName</code>—the class being derived <br><code>specification</code>—specifies access to the base class members</p>
<code>public<br> protected<br> private<br> private by default</code>
<p>the keyword <code>virtual</code> identifies <code>BaseClassName</code> as a virtual base class of <code>DerivedClassName</code>.</p>
<p>Schematically, we now have a situation that, as the figure shows, looks like more stuff for the classes to point to.</p>
<p><span class="title"><span class="bold">Virtual Base Classes</span></span></p>
<p><img src="./Lesson 10_files/c++711s10fig10-06.gif" alt="virtual base classes" width="413" height="149" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384305" data-api-returntype="File" style="max-width: 962px;"></p>
<p>Let's look at an example.</p>
<pre>// Classes Derivation - Multiple Inheritance Example
// Simple Inheritance - Virtual Base Class

class Fruit
{
public:
    Fruit(
        int stem = 1,
        int seeds = 4)
        : myStem(stem), mySeeds(seeds)
    {
    }

    virtual std::string identify() const
    {
        return "Fruit";
    }

    virtual std::string skin() const = 0;

    int getStem() const
    {
        return myStem;
    }

private:
    int myStem;
    int mySeeds;
};

//  Fruit will be a virtual base class of Plum and Peach
class Plum: public virtual Fruit
{
public:
    Plum()
        : Fruit(2, 1)
    {
    }

    std::string identify() const
    {
        return "Plum";
    }

    std::string skin() const
    {
        return "Smooth";
    }
};

class Peach : public virtual Fruit
{
public:
    Peach()
        : Fruit(3, 4)
    {
    }

    std::string identify() const
    {
        return "Peach";
    }

    std::string skin() const
    {
        return "Fuzzy";
    }
};

class Nectarine: public Plum, public Peach
{
public:
    Nectarine()
    {
    }

    std::string identify() const
    {
        return "Nectarine";
    }

    std::string skin() const
    {
        return "Smooth";
    }
};

TEST(virtualBaseClasses, Class)
{
    Nectarine *np = new Nectarine;

    CHECK_EQUAL("Nectarine", np-&gt;identify());
    CHECK_EQUAL("Smooth", np-&gt;skin());
    CHECK_EQUAL(1, np-&gt;getStem());

    delete np;
}</pre>
<p>Since virtual inheritance is complex, avoid it when possible. There are most always better design options.</p>
<h4>Access Protection</h4>
<p>Now let's consider the situation shown in the hierarchy shown:</p>
<p class="title"><span class="bold">Which Access Specification Dominates?</span></p>
<p><img src="./Lesson 10_files/c++711s10fig10-07.gif" alt="which access specification dominates?" width="272" height="157" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384257" data-api-returntype="File" style="max-width: 962px;"></p>
<p>There are two paths shown to D, one public and the other private. Which access specification dominates? In C++, the rule is that the most public path always dominates.</p>
<h4>Virtual Base Class Initialization</h4>
<p>Notice that in the last example the value of <code>stem</code> is set to 3. Was this just an accident? Nope. In derivation hierarchies such as we've been looking at, which child gets to initialize the virtual base class? Simply put, the most derived class. In the example, once again, since Nectarine did not initialize the inherited member, Peach, the last specified base class does. In C++, initialization proceeds as follows:</p>
<ol>
<li>Constructors for any virtual base class in the derivation hierarchy. If there are multiple virtual base classes, the constructors are invoked in the order specified on the derivation list.</li>
<li>Constructors for each non-virtual base class in the order specified in the derivation list.</li>
<li>It is the responsibility of the most derived class to provide initialization values, via the init list, for any parameterized base class constructors.</li>
</ol>
<p>Specify class E as</p>
<pre>class E : public D, public C, public virtual F </pre>
<p>E will be the one to initialize A and F.</p>
<h4>Override</h4>
<p>A derived class may implement a virtual function defined in the base class. This is called overriding the virtual function.&nbsp; C++ supports implicit overriding. That is, if the signature of the function in the derived class matches that of the base class, the function is implicitly overridden. The following code makes use of implicit override:</p>
<pre>class Animal
{
public:
    virtual void eat() = 0;
};

class Dog : public Animal
{
public:
    // implicit override - signature matches that of the virtual function eat defined in the base class
    void eat()
    {
        std::cout &lt;&lt; "dog is eating" &lt;&lt; std::endl;
    }
};

TEST(override, Animal)
{
    Dog d;
}</pre>
<p>The override keyword makes explicit a derived class is implementing a virtual function declared in a base class:</p>
<pre>class Animal
{
public:
    virtual void eat() = 0;
};

class Dog : public Animal
{
public:
    // implicit override - signature matches that of the virtual function eat defined in the base class
    void eat() override // explicit override
    {
        std::cout &lt;&lt; "dog is eating" &lt;&lt; std::endl;
    }
};

TEST(override, Animal)
{
    Dog d;
}</pre>
<p>Explicit overrides have the advantage of telling the compiler your intention. The compiler can then help you override correctly by ensuring the prerequisites for override are met. These are</p>
<ul>
<li>
<p style="text-align: left;">The base class as defined a virtual function</p>
</li>
<li>
<p style="text-align: left;">The desired derived class function override matches the signature of the virtual function exactly.</p>
</li>
</ul>
<p style="text-align: left;">With implicit override it can be easy to make a mistake in the signature of the virtual function in the derived class. In this case, the compiler just defines a brand new independent member function.</p>
<h4 style="text-align: left;">Final</h4>
<p style="text-align: left;">The final keyword is used in a derived class to signify that a function override is the final override. That is, the next derived class is not allowed to override the member function:</p>
<pre style="text-align: left;">class Animal
{
public:
    virtual void eat() = 0;
};

class Dog : public Animal
{
public:
    // implicit override - signature matches that of the virtual function eat defined in the base class
    void eat() override // explicit override
    {
        std::cout &lt;&lt; "dog is eating" &lt;&lt; std::endl;
    }
};

class Puppy : public Dog
{
public:
    void eat() final 
    {
        std::cout &lt;&lt; "puppy is eating" &lt;&lt; std::endl;
    }
};

class HappyPuppy : public Puppy
{
public:
    void eat() // compiler error - eat declared as final in Puppy
    {
        std::cout &lt;&lt; "puppy is eating" &lt;&lt; std::endl;
    }
};

TEST(override, Animal)
{
    Dog d;
}</pre>
<p style="text-align: left;">Final is used to enforce design.</p>
<h3>Summary</h3>
<p>In this lesson, we introduced the concept of runtime polymorphism and discussed its implementation in C++ through virtual functions and late binding. We then moved inside the class structure to look at the mechanics of how such a scheme is implemented using vpointers and the vtable. We concluded with pure virtual functions, abstract base classes, virtual base classes, and the problem of object slicing.</p>
<h3>Practice&nbsp;Questions</h3>
<p>Test your understanding of the concepts in Lesson 10 by working through&nbsp;the following practice questions, then check your answers with <a class="" title="Answers to Practice Questions for Lesson 10" href="https://canvas.uw.edu/courses/1177926/pages/answers-to-practice-questions-for-lesson-10" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/pages/answers-to-practice-questions-for-lesson-10" data-api-returntype="Page">Answers to Practice Questions for Lesson 10</a>.</p>
<ol>
<li>How is polymorphism implemented in C++?</li>
<li>What is the purpose of an abstract base class (ABC)?</li>
<li>How is a virtual function declared?</li>
<li>Can a virtual function be overloaded?</li>
<li>How is a virtual function invoked?</li>
<li>Why should you use a virtual destructor?</li>
<li>How do we declare a pure virtual function?</li>
<li>Why should a derived class object be passed to a function expecting a base class object by reference rather than by value?</li>
</ol>

  
</div>
<div style=""><div class="module-sequence-padding"></div>
<div class="module-sequence-footer" role="navigation" aria-label="Module Navigation">
  <div class="module-sequence-footer-content">
    
      <a href="https://canvas.uw.edu/courses/1177926/modules/items/7889577" role="button" class="Button module-sequence-footer-button--previous" data-tooltip="right" data-html-tooltip-title="&lt;i class=&#39;icon-document&#39;&gt;&lt;/i&gt; Lesson 10 Overview and Materials" aria-describedby="msf0-previous-desc">
        <i class="icon-mini-arrow-left"></i>Previous
        <span id="msf0-previous-desc" class="hidden" hidden="">Previous: Lesson 10 Overview and Materials</span>
      </a>
    

    
      <span class="module-sequence-footer-button--next" data-tooltip="left" data-html-tooltip-title="&lt;i class=&#39;icon-discussion&#39;&gt;&lt;/i&gt; Lesson 10 Discussion">
        <a href="https://canvas.uw.edu/courses/1177926/modules/items/7889579" role="button" class="Button" aria-describedby="msf0-next-desc">
          Next<i class="icon-mini-arrow-right"></i>
          <span id="msf0-next-desc" class="hidden" hidden="">Next: Lesson 10 Discussion</span>
        </a>
      </span>
    
  </div>
</div>
</div></div>

          </div>
        </div>
        <div id="right-side-wrapper" class="ic-app-main-content__secondary">
          <aside id="right-side" role="complementary">
            
          </aside>
        </div>
      </div>
    </div>
  </div>



    <div style="display:none;"><!-- Everything inside of this should always stay hidden -->
        <div id="page_view_id">979b1368-c306-4269-a17c-c10913fda6d5</div>
    </div>
  <div id="aria_alerts" class="hide-text affix" role="alert" aria-live="assertive"></div>
  <div id="StudentTray__Container"></div>
  

<script>
  INST = {"environment":"production","allowMediaComments":true,"kalturaSettings":{"domain":"nv.instructuremedia.com","resource_domain":"nv.instructuremedia.com","rtmp_domain":"fms-prod.instructuremedia.com","partner_id":"9","subpartner_id":"0","player_ui_conf":"0","kcw_ui_conf":"0","upload_ui_conf":"0","max_file_size_bytes":534773760,"do_analytics":false,"hide_rte_button":false,"js_uploader":true},"googleAnalyticsAccount":"UA-9138420-1","logPageViews":true,"maxVisibleEditorButtons":3,"editorButtons":[{"name":"","id":21130,"url":"https://uw.hosted.panopto.com/Panopto/Pages/Sessions/embeddedupload.aspx","icon_url":"https://uw.hosted.panopto.com/Panopto/images/panopto_logo_globe.png","canvas_icon_class":null,"width":900,"height":700},{"name":"Modalis","id":52765,"url":"https://uw.modalis.io/lti","icon_url":"https://uw.modalis.io/assets/richicon.png","canvas_icon_class":null,"width":800,"height":600}]};
  ENV = {"ASSET_HOST":"https://du11hjcvx0uqb.cloudfront.net","active_brand_config_json_url":"https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/171115bc27094614cfdd1485c405a438/variables-750d72b9d3e5d522f965bf904110c132.json","url_to_what_gets_loaded_inside_the_tinymce_editor_css":["https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/171115bc27094614cfdd1485c405a438/variables-750d72b9d3e5d522f965bf904110c132.css","https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/new_styles_normal_contrast/bundles/what_gets_loaded_inside_the_tinymce_editor-53dac18d10.css"],"url_for_high_contrast_tinymce_editor_css":["https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/default/variables-high_contrast-750d72b9d3e5d522f965bf904110c132.css","https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/new_styles_high_contrast/bundles/what_gets_loaded_inside_the_tinymce_editor-b4d65fe883.css"],"current_user_id":"3757111","current_user_roles":["user","student"],"current_user_disabled_inbox":false,"files_domain":"cluster10-files.instructure.com","DOMAIN_ROOT_ACCOUNT_ID":100000000083919,"k12":false,"use_responsive_layout":false,"help_link_name":"Help","help_link_icon":"help","use_high_contrast":false,"LTI_LAUNCH_FRAME_ALLOWANCES":["geolocation *","microphone *","camera *","midi *","encrypted-media *"],"SETTINGS":{"open_registration":false,"eportfolios_enabled":true,"collapse_global_nav":true,"show_feedback_link":true,"enable_profiles":true},"current_user":{"id":"3757111","display_name":"Clayton Wong","avatar_image_url":"https://canvas.uw.edu/images/thumbnails/46487823/mSs2TjTESYscSzrackhgoJvAT79xbNchamHPrSec","html_url":"https://canvas.uw.edu/about/3757111"},"page_view_update_url":"/page_views/979b1368-c306-4269-a17c-c10913fda6d5?page_view_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpIjoiOTc5YjEzNjgtYzMwNi00MjY5LWExN2MtYzEwOTEzZmRhNmQ1IiwidSI6MTAwMDAwMDAzNzU3MTExLCJjIjoiMjAxOC0wOC0xNFQyMTo1MTo1Ny45MFoifQ.yy3Vf6j6XPpIMIzAaSjtvaVAANJRg9JfGgFPJ9vZ4Tc","context_asset_string":"course_1177926","ping_url":"https://canvas.uw.edu/api/v1/courses/1177926/ping","TIMEZONE":"America/Los_Angeles","CONTEXT_TIMEZONE":"America/Los_Angeles","LOCALE":"en","BIGEASY_LOCALE":"en_US","FULLCALENDAR_LOCALE":"en","MOMENT_LOCALE":"en","WIKI_RIGHTS":{"read":true},"PAGE_RIGHTS":{"read":true},"DEFAULT_EDITING_ROLES":"teachers","WIKI_PAGES_PATH":"/courses/1177926/pages","WIKI_PAGE":{"title":"Lesson 10","created_at":"2017-10-18T21:04:16Z","url":"lesson-10","editing_roles":"teachers","page_id":"2573106","last_edited_by":{"id":"616135","display_name":"UW Online","avatar_image_url":"https://canvas.uw.edu/images/thumbnails/48906042/5fiFTncigBVESajokiO6KZAa8tp5cr2EYSaKvX8M","html_url":"https://canvas.uw.edu/courses/1177926/users/616135"},"published":true,"hide_from_students":false,"front_page":false,"html_url":"https://canvas.uw.edu/courses/1177926/pages/lesson-10","todo_date":null,"updated_at":"2018-06-08T23:23:15Z","locked_for_user":false,"body":"\u003ch2\u003e\u003cspan\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384332/preview\" alt=\"L10.png\" width=\"50\" height=\"50\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384332\" data-api-returntype=\"File\"\u003e C++ and Polymorphism\u003c/span\u003e\u003c/h2\u003e\r\n\u003cdiv class=\"keytermBox\" style=\"background-color: #F3F3E9;\"\u003e\r\n\u003ch6\u003eKey Terms\u003c/h6\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eearly binding\u003c/li\u003e\r\n\u003cli\u003elate binding\u003c/li\u003e\r\n\u003cli\u003einterface\u003c/li\u003e\r\n\u003cli\u003eimplementation\u003c/li\u003e\r\n\u003cli\u003enon-virtual function\u003c/li\u003e\r\n\u003cli\u003epure virtual function\u003c/li\u003e\r\n\u003cli\u003eabstract class\u003c/li\u003e\r\n\u003cli\u003econcrete class\u003c/li\u003e\r\n\u003cli\u003estatic binding (or compile time binding)\u003c/li\u003e\r\n\u003cli\u003edynamic binding (or run time binding)\u003c/li\u003e\r\n\u003cli\u003epolymorphic\u003c/li\u003e\r\n\u003cli\u003evtable (vtbl)\u003c/li\u003e\r\n\u003cli\u003evpointer (vptr)\u003c/li\u003e\r\n\u003cli\u003evirtual base class\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003c/div\u003e\r\n\u003ch3\u003eInheritance and Runtime Polymorphism in C++\u003c/h3\u003e\r\n\u003ch4\u003eGetting Acquainted\u003c/h4\u003e\r\n\u003cp\u003eOne of the pillars of the object oriented programming is the concept of polymorphism. The idea behind polymorphic behavior is to have the same general type of action accomplished in different ways by different types of objects. C++ permits the programmer to call the same member function on different but related objects to achieve different but related actions.\u003c/p\u003e\r\n\u003cp\u003eThe polymorphic approach also helps to reduce complexity from both the designer's and the user's perspective by permitting a common interface to specify a more general class of actions. As we move toward generic programs, we will learn to abstract the functionality of the program from the underlying data types. Different classes, related through inheritance, respond differently, yet appropriately, to the same message with different member function calls. Once again, such a design philosophy provides us reusable code. Reusable code allows us to extend a class through inheritance and have the new object respond to existing messages.\u003c/p\u003e\r\n\u003cp\u003eA key element of polymorphism lies in the process of binding or connecting a function call with the function body. In C++, we establish such a link either at compile time, which we call \u003cspan class=\"keyterm\"\u003eearly binding\u003c/span\u003e, or at runtime, which we call \u003cspan class=\"keyterm\"\u003elate binding\u003c/span\u003e.\u003c/p\u003e\r\n\u003cp\u003eWe implement early binding through coding function calls in such a way that the exact function being called is known at compile time. Such an approach allows us to achieve greater execution speed and runtime efficiency through code optimization. Late binding is when the exact function being called is not known until the program runs. In C we could accomplish this using pointers to functions. In C++, late binding is implemented with virtual functions.\u003c/p\u003e\r\n\u003ch3\u003eThe Concept of Inheritance\u003c/h3\u003e\r\n\u003cp\u003eIn our last two lessons, we've seen that inheritance introduces the concept of a collection of classes with many shared characteristics. People often think that this is what C++ is all about. The idea of shared characteristics or, more specifically, a common interface is consistent with the concept of polymorphism. Polymorphism focuses on both inheritance and abstraction.\u003c/p\u003e\r\n\u003cp\u003eWhen we think about inheritance, we must consider what is being inherited. When we look at the public interface of a class, we see it comprises two separate parts. We have the \u003cspan class=\"keyterm\"\u003einterface\u003c/span\u003e and the \u003cspan class=\"keyterm\"\u003eimplementation\u003c/span\u003e(s). If we want the parent class interface to be overridden, then we should use virtual functions. In contrast, to prohibit overriding, we should use \u003cspan class=\"keyterm\"\u003enon-virtual functions\u003c/span\u003e. If we want to propagate the interface, then we should choose \u003cspan class=\"keyterm\"\u003epure virtual functions\u003c/span\u003e.\u003c/p\u003e\r\n\u003ch3\u003eAbstract Base Classes and Virtual Functions\u003c/h3\u003e\r\n\u003cp\u003eLate binding polymorphism in C++ is implemented through two ideas, abstract base classes and virtual functions. Let's examine each of these in turn.\u003c/p\u003e\r\n\u003ch4\u003eAbstract Base Classes: A First Look\u003c/h4\u003e\r\n\u003cp\u003eGenerally a class is designed to have instances. However, there are cases in which it is useful to design classes that are never intended to have instances. Such classes are called \u003cspan class=\"keyterm\"\u003eabstract classes\u003c/span\u003e. They cannot have instances—there are no objects of the abstract class type. The class Vehicles can serve as a base from which to derive automobiles, boats, aircraft, or spaceships, yet, as we've seen, a Vehicle does not exist in a concrete sense.\u003c/p\u003e\r\n\u003cp\u003eWe can, however, have pointers of an abstract class type. Such pointers can be used to polymorphically manipulate derived class instances. The sole purpose of such classes is to provide a common public interface to the class hierarchy and as the basis from which to derive other classes. These are referred to as \u003cspan class=\"keyterm\"\u003eabstract base classes\u003c/span\u003e (\u003cspan class=\"keyterm\"\u003eABC\u003c/span\u003e). We use them to provide a common subset of properties to a complete collection of related classes. Classes derived from an ABC (and instantiated) are thus called \u003cspan class=\"keyterm\"\u003econcrete classes\u003c/span\u003e.\u003c/p\u003e\r\n\u003ch4\u003eVirtual Functions: A First Look\u003c/h4\u003e\r\n\u003cp\u003eA virtual function is a mechanism for inheriting a functional interface and default implementation for such a function. A virtual function must be declared and defined in a parent class. Its declaration is preceded by the keyword virtual and its name can only be used once in the parent class. We can't overload a virtual function, and only class member functions can be declared virtual. The syntax for such a declaration takes two forms.\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003evirtual function:\u003cbr\u003e\u003ccode\u003evirtual returnType functionName(args ) \u003cbr\u003e { function body }\u003c/code\u003e\n\u003c/li\u003e\r\n\u003cli\u003epure virtual function:\u003cbr\u003e\u003ccode\u003evirtual returnType functionName(args) = 0;\u003c/code\u003e\n\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eA function is virtual if it is declared virtual, or if there is a base class function with the same name and signature that has been declared virtual. Any or all class member functions (except the constructor) can be declared virtual. Although a virtual function does not have to be explicitly so annotated in a derived class, it's good practice to do so. Anything we can put into our code to simplify, clarify, and communicate to others should be done. Comments and annotation don't generate object code—they're free.\u003c/p\u003e\r\n\u003ch4\u003eRegular Virtual Functions\u003c/h4\u003e\r\n\u003cp\u003eLet's look at this first example and see what we're really getting with all this virtual stuff. In the base class (\u003ccode\u003eFruit\u003c/code\u003e), we've declared the function\u003ccode\u003e identify()\u003c/code\u003e to be virtual. It now becomes virtual throughout the class hierarchy. Next, if we use a base class pointer to \u003ccode\u003eFruit\u003c/code\u003e, initialized to point to a derived classinstance \u003ccode\u003eApple\u003c/code\u003e and invoke the \u003ccode\u003eidentify()\u003c/code\u003e member function, we get the function associated with the Apple class. Had \u003ccode\u003eidentify()\u003c/code\u003e not been virtual, we would have gotten the one from \u003ccode\u003eFruit\u003c/code\u003e. We've gotten the function associated with the type of the \u003cspan class=\"bold\"\u003eobject\u003c/span\u003e, not the type of the \u003cspan class=\"bold\"\u003epointer\u003c/span\u003e. The virtual mechanism is at work.\u003c/p\u003e\r\n\u003cp\u003eSuch an example may be interesting for picking fruit. In a larger sense, the virtual mechanism enables us to use a public base class pointer, instantiated to the address of any of the members of the derived class, and have the appropriate behavior invoked. In the Example below, we'll revisit our \u003ccode\u003eFruit\u003c/code\u003e hierarchy.\u003c/p\u003e\r\n\u003cpre\u003e#include \"TestHarness.h\"\u003cbr\u003e\u003cbr\u003e// Classes Derivation - Single Inheritance Example\u003cbr\u003e// Simple Inheritance - Virtual Functions\u003cbr\u003e\u003cbr\u003e#include \u0026lt;memory\u0026gt;\u003cbr\u003e\u003cbr\u003eclass Fruit\u003cbr\u003e{\u003cbr\u003epublic:\u003cbr\u003e Fruit() : stem(1), seeds(4)\u003cbr\u003e {\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e virtual ~Fruit() = default;\u003cbr\u003e\u003cbr\u003e virtual std::string identify() const\u003cbr\u003e {\u003cbr\u003e return \"Fruit\";\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e int getStem() const\u003cbr\u003e {\u003cbr\u003e return stem;\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003eprivate:\u003cbr\u003e int stem;\u003cbr\u003e int seeds;\u003cbr\u003e};\u003cbr\u003e\u003cbr\u003eclass Apple : public Fruit\u003cbr\u003e{\u003cbr\u003epublic:\u003cbr\u003e Apple() : skin(2)\u003cbr\u003e {\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e std::string identify() const override\u003cbr\u003e {\u003cbr\u003e return \"Apple\";\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e int getSkin() const\u003cbr\u003e {\u003cbr\u003e return skin;\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003eprivate:\u003cbr\u003e int skin;\u003cbr\u003e};\u003cbr\u003e\u003cbr\u003eTEST(polymorphism, Lesson10)\u003cbr\u003e{\u003cbr\u003e auto fp = std::make_unique\u0026lt;Apple\u0026gt;();\u003cbr\u003e auto ap = std::make_unique\u0026lt;Apple\u0026gt;();\u003cbr\u003e\u003cbr\u003e // via polymorphism - call Apple's implementation of identify\u003cbr\u003e CHECK_EQUAL(\"Apple\", fp-\u0026gt;identify());\u003cbr\u003e CHECK_EQUAL(1, fp-\u0026gt;getStem());\u003cbr\u003e\u003cbr\u003e // fp-\u0026gt;getSkin(); // error - skin not a member of fruit\u003cbr\u003e CHECK_EQUAL(\"Apple\", ap-\u0026gt;identify());\u003cbr\u003e\u003cbr\u003e auto fp1 = std::make_unique\u0026lt;Fruit\u0026gt;();\u003cbr\u003e\u003cbr\u003e // via polymorphism - call Fruit's implementation of identify\u003cbr\u003e CHECK_EQUAL(\"Fruit\", fp1-\u0026gt;identify());\u003cbr\u003e}\u003c/pre\u003e\r\n\u003cp\u003eThe code for a regular virtual function must be supplied in the parent class. A derived class may optionally replace the code provided by the base class in the virtual function. This is called overriding the virtual function.\u003c/p\u003e\r\n\u003ch4\u003ePure Virtual Functions\u003c/h4\u003e\r\n\u003cp\u003eA pure virtual function is declared as:\u003c/p\u003e\r\n\u003cpre\u003eclass Fruit\r\n{\r\n    ...\r\n    virtual bool hasSeeds() const = 0;\r\n};       \u003c/pre\u003e\r\n\u003cp\u003eWhere = 0 denotes the function is pure virtual. Pure virtual functions mmust be overridden in the derived class. Regular virtual functions may be overridden in a derived class.\u003c/p\u003e\r\n\u003cp\u003eA derived class can choose to override the definition by providing its own implementation; however, it cannot redefine the return type. We'll see in the advanced course that there are some exceptions.\u003c/p\u003e\r\n\u003cp\u003eIf the re-declaration in a derived class does not match exactly, the function is not virtual for that class. The derived class name then hides the virtual function. In most situations hiding a virtual function is either a coding error, or a design error. We can still have a virtual function in a subsequently derived class. It is an error if the derived and base class functions differ only in return type.\u003c/p\u003e\r\n\u003cpre\u003e#include \"TestHarness.h\"\u003cbr\u003e\u003cbr\u003e#include \u0026lt;memory\u0026gt;\u003cbr\u003e\u003cbr\u003e#include \u0026lt;string\u0026gt;\u003cbr\u003e\u003cbr\u003eclass Fruit\u003cbr\u003e{\u003cbr\u003epublic:\u003cbr\u003e explicit Fruit(int stem = 1) : myStem(stem)\u003cbr\u003e {\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e virtual ~Fruit() = default;\u003cbr\u003e\u003cbr\u003e virtual std::string identify() const\u003cbr\u003e {\u003cbr\u003e return \"Fruit\";\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e int getStem() const\u003cbr\u003e {\u003cbr\u003e return myStem;\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003eprivate:\u003cbr\u003e int myStem;\u003cbr\u003e};\u003cbr\u003e\u003cbr\u003eclass Apple : public Fruit\u003cbr\u003e{\u003cbr\u003epublic:\u003cbr\u003e explicit Apple(int skin = 2, int stem = 1)\u003cbr\u003e : Fruit(stem),\u003cbr\u003e mySkin(2)\u003cbr\u003e {\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e std::string identify() const override\u003cbr\u003e {\u003cbr\u003e return \"Apple\";\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003eprivate:\u003cbr\u003e int mySkin;\u003cbr\u003e};\u003cbr\u003e\u003cbr\u003eclass CrabApple : public Apple\u003cbr\u003e{\u003cbr\u003epublic:\u003cbr\u003e CrabApple()\u003cbr\u003e : Apple(3, 4)\u003cbr\u003e {\u003cbr\u003e }\u003cbr\u003e\u003cbr\u003e std::string identify() const override\u003cbr\u003e {\u003cbr\u003e return \"CrabApple\";\u003cbr\u003e }\u003cbr\u003e};\u003cbr\u003e\u003cbr\u003eTEST(polymorphism2, Lesson10)\u003cbr\u003e{\u003cbr\u003e // Use base class pointer to point\u003cbr\u003e // to a derived class objects\u003cbr\u003e auto fp = std::make_unique\u0026lt;Apple\u0026gt;();\u003cbr\u003e auto cap = std::make_unique\u0026lt;CrabApple\u0026gt;();\u003cbr\u003e\u003cbr\u003e CHECK_EQUAL(\"Apple\", fp-\u0026gt;identify());\u003cbr\u003e CHECK_EQUAL(1, fp-\u0026gt;getStem());\u003cbr\u003e CHECK_EQUAL(\"CrabApple\", cap-\u0026gt;identify());\u003cbr\u003e\u003cbr\u003e // Fruit tracks the number of stems. Note how CrapApples\u003cbr\u003e // constructor passes the number of stems to Fruit\u003cbr\u003e CHECK_EQUAL(4, cap-\u0026gt;getStem());\u003cbr\u003e}\u003c/pre\u003e\r\n\u003ch3\u003eVirtual Functions in Detail\u003c/h3\u003e\r\n\u003ch4\u003ePutting It Together\u003c/h4\u003e\r\n\u003cp\u003eThe purpose of declaring a virtual function is to permit the derived class to inherit the functional interface. We may also decide to provide a default implementation from in the parent class. If the virtual function is pure virtual we don't have to provide a default implementation in the base class. A derived class can override the definition by providing its own implementation. Observe that we are overriding, not overloading. We are changing the body, not the signature of the function. We are permitted to both override and overload a function within the same class.\u003c/p\u003e\r\n\u003cp\u003eSuch a capability permits multiple functions to be called through a common interface. The virtual mechanism can be overridden by explicit qualification with the scope operator. Our class hierarchy now appears as shown below. Polymorphism gives us a uniform function call interface to the hierarchy.\u003c/p\u003e\r\n\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384256/preview\" alt=\"class hierarchy\" width=\"305\" height=\"248\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384256\" data-api-returntype=\"File\"\u003e\u003cbr\u003e\r\n\u003cp\u003eWhen a function in a class is declared virtual, the keyword \u003ccode\u003evirtual\u003c/code\u003e tells the compiler not to perform early binding and to install mechanisms to perform late binding. The compiler responds by creating a table of function pointers and installing a data member to the class to point to the table. This table is called the \u003cspan class=\"keyterm\"\u003evtable\u003c/span\u003e or \u003cspan class=\"keyterm\"\u003evtbl\u003c/span\u003e. The \u003cspan class=\"italics\"\u003evtbl\u003c/span\u003e contains pointers to all functions declared virtual within the class and the derived classes. It's typically implemented as an array of pointers to functions although some compilers will use a linked list. These are now non-member functions—not inlined. Each class within a hierarchy gets its own vtable and the table contains only pointers to virtual functions. There is only one virtual table per class.\u003c/p\u003e\r\n\u003cp\u003eWhen virtual functions are used, memory must be set aside for a vtable in each class that contains virtual functions. The size of the vtable will be proportional to the number of virtual functions in the class. Generally, abstract classes have no vtable. Since vtables can only be referenced by an object and abstract classes are not instantiated, vtables are unnecessary.\u003c/p\u003e\r\n\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384311/preview\" alt=\"Base class and Vtable\" width=\"439\" height=\"133\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384311\" data-api-returntype=\"File\"\u003e\u003cbr\u003e\r\n\u003cp\u003eA data member, called a \u003cspan class=\"keyterm\"\u003evpointer\u003c/span\u003e or \u003cspan class=\"keyterm\"\u003evptr\u003c/span\u003e, is (in most cases) placed as the first element in the object in memory and initialized to the starting address of the vtable. The initialization is done in the constructor (or a compiler generated default) using code the compiler has added. Consequently, we cannot make a virtual function call before the vpointer is initialized. Each object of a class containing virtual functions must have this extra pointer. So now each object using virtual functions has a this pointer and a vpointer.\u003c/p\u003e\r\n\u003cp\u003eA function call through the base class pointer, therefore, knows the type of the object for which the call is being made. From here, the function call code follows the vptr to the vtbl. This is a simple operation; the compiler knows where the vptr is in the object—after all, it put it there. Thus, we have an offset operation from the start of the object followed by an indirection into the vtbl. To find the pointer in the vtbl to the function being called, we index into the array—offset into the vtbl—to invoke the function located at the target address. This is generally an efficient operation.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eBase Class, Derived Class, and Vtable\u003c/span\u003e\u003c/p\u003e\r\n\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384307/preview\" alt=\"base class, derived class, and Vtable\" width=\"483\" height=\"342\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384307\" data-api-returntype=\"File\"\u003e\u003cbr\u003e\r\n\u003cp\u003eIn the second figure, note that if \u003ccode\u003ek()\u003c/code\u003e had not been redefined, the address in the vtable would be that of the base class version.\u003c/p\u003e\r\n\u003ch4\u003eInvoking a Virtual Function\u003c/h4\u003e\r\n\u003cp\u003eA virtual function is invoked through a public base class reference or pointer. The binding is typically dynamic at runtime. Virtual functions are not inlined. As we know, inlining tells the compiler to replace the function call with the body of the function. Since the whole intent of polymorphism, however, is to defer such a decision until runtime, the compiler will be long gone. Inlining is generally something we give up when we use virtual functions.\u003c/p\u003e\r\n\u003cp\u003eIn the case of virtual functions, the function to be invoked is determined by the class type of the actual object addressed by the reference or pointer. For non-virtual functions, it's determined by the class type of the pointer or reference.\u003c/p\u003e\r\n\u003ch4\u003eAccess Protection\u003c/h4\u003e\r\n\u003cp\u003eThe access level of a virtual function is determined, indirectly, by the class type of the pointer through which the virtual function is invoked, not by the class in which it's defined.\u003c/p\u003e\r\n\u003cpre\u003e    A\r\n    B : public A\r\n    C : public B\r\n    D : public C\r\n    E : public D\u003c/pre\u003e\r\ndeclare\r\n\u003cp\u003epublic virtual function \u003ccode\u003ef1()\u003c/code\u003e in \u003ccode\u003eA\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003eprotected virtual function \u003ccode\u003ef1()\u003c/code\u003e in \u003ccode\u003eB\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003eprivate virtual function \u003ccode\u003ef1()\u003c/code\u003e in \u003ccode\u003eC\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003epublic virtual function \u003ccode\u003ef1()\u003c/code\u003e in \u003ccode\u003eD\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003edefine\u003c/p\u003e\r\n\u003ccode\u003eA* a = new B; \u003c/code\u003e\r\n\u003cp\u003e\u003ccode\u003ea = new C; \u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003ccode\u003eC* c = new D; \u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003ewrite\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px; margin-bottom: 0px;\"\u003e\u003ccode\u003ea-\u0026gt;f1(); // f1 ()\u003c/code\u003e is accessible through \u003ccode\u003e*a as a *B\u003c/code\u003e\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px;\"\u003e\u003ccode\u003ef1() \u003c/code\u003ewas declared in the public portion of \u003ccode\u003eA\u003c/code\u003e\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px; margin-bottom: 0px;\"\u003e\u003ccode\u003ea-\u0026gt;f1(); // f1 ()\u003c/code\u003e is accessible through \u003ccode\u003e*a as a *C\u003c/code\u003e\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px;\"\u003e\u003ccode\u003ef1() \u003c/code\u003ewas declared in the public portion of \u003ccode\u003eA\u003c/code\u003e\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px; margin-bottom: 0px;\"\u003e\u003ccode\u003ec-\u0026gt;f1(); // f1 ()\u003c/code\u003e not accessible through \u003ccode\u003e*c as a *D\u003c/code\u003e\u003c/p\u003e\r\n\u003cp style=\"margin-top: 0px;\"\u003e\u003ccode\u003ef1() \u003c/code\u003ewas declared in the private portion of \u003ccode\u003eC\u003c/code\u003e\u003c/p\u003e\r\n\u003ch3\u003eVirtual Destructors\u003c/h3\u003e\r\n\u003cp\u003eConsider what happens when we use a base class pointer to refer to a derived class instance.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eExample 10.4\u003c/span\u003e\u003c/p\u003e\r\n\u003cpre\u003e// Classes Derivation - Single Inheritance Example\r\n// Simple Inheritance - Virtual Destructors\r\n\r\nclass A\r\n{\r\npublic:\r\n    A()\r\n    {\r\n    }\r\n\r\n    ~A()\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"Destroying A\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n\r\n    virtual std::string identify() const\r\n    {\r\n        return \"A\";\r\n    }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    B()\r\n    {\r\n    }\r\n\r\n    ~B()\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"Destroying B\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n\r\n    std::string identify() const\r\n    {\r\n        return \"B\";\r\n    }\r\n};\r\n\r\nTEST(VirtualDestructures, Class)\r\n{\r\n    A* a = new B;\r\n    CHECK_EQUAL(\"B\", a-\u0026gt;identify());\r\n\r\n    // ERROR: will print Destroying A\r\n    // B's destructor is not called!\r\n    // What we want is for the destructors to be chained. First we want B::~B to be called, then we want A::~A called\r\n    delete a;\r\n}\u003c/pre\u003e\r\n\u003cp\u003eObserve that the expression \u003ccode\u003edelete a\u003c/code\u003e only invokes the class \u003ccode\u003eA\u003c/code\u003e destructor with the result that only the memory associated with the \u003ccode\u003eA\u003c/code\u003e part of the \u003ccode\u003eB\u003c/code\u003e object is deinitialized. We want the destructors for both classes to be invoked. Since \u003ccode\u003e*a\u003c/code\u003e is a base class pointer, only the \u003ccode\u003eA\u003c/code\u003e destructor is invoked.\u003c/p\u003e\r\n\u003cp\u003eTo see why this happens, recall that with non-virtual functions, the function invoked is determined by the type of the pointer to the object, not by the type of the object. Here we are using an \u003ccode\u003eA\u003c/code\u003e type pointer; the destructor is not virtual, so we get the function associated with \u003ccode\u003eA\u003c/code\u003e—the class \u003ccode\u003eA\u003c/code\u003e destructor. To fix the problem, we simply declare the base class destructor to be virtual. The syntax for such a declaration is as we'd expect:\u003c/p\u003e\r\n\u003cpre\u003evirtual ~class ClassName() { destructor body }\u003c/pre\u003e\r\n\u003cp\u003eNow if we repeat the previous example with the base class destructor declared virtual, we'll get both destructors invoked.\u003c/p\u003e\r\n\u003cp\u003eAs with a virtual function, if a base class declares a destructor virtual, every destructor in the derivation hierarchy is virtual. Specifying a base class destructor to be virtual guarantees that the appropriate destructors will be invoked whenever delete is applied to the object at the end of a base class pointer. A general rule of thumb suggests that if a class is abstract, by virtue of having one or more virtual functions, the destructor should always be declared virtual.\u003c/p\u003e\r\n\u003cp\u003eIf the class is not abstract, there's no need to expend the extra memory for the vtable and all of the associated pointers. As with non-virtual destructors, the invocation of a chain of virtual destructors begins with the most derived class and unwinds up the derivation chain to the base.\u003c/p\u003e\r\n\u003ch3\u003eAbstract Base Classes, Virtual Functions, and Pure Virtual Functions\u003c/h3\u003e\r\n\u003ch4\u003eVirtual Functions Again\u003c/h4\u003e\r\n\u003cp\u003eLet's begin the discussion of pure virtual functions by looking at virtual functions. Recall that a virtual function must be defined when it's declared. Such a definition may not always be appropriate. Consider a potential problem with a simple virtual function. Let's define the following class hierarchy:\u003c/p\u003e\r\n\u003cpre\u003eclass BaseClass\r\n{\r\npublic:\r\n    // provide a default definition of  dFunct()\r\n    virtual int dFunct() const\r\n    {\r\n        return 12;\r\n    }\r\n};\r\n\r\nclass DerivedClass1 : public BaseClass\r\n{\r\npublic:\r\n    // redefine default definition of dFunct()\r\n    virtual int dFunct() const\r\n    {\r\n        return 3;\r\n    }\r\n};\r\n\r\nclass DerivedClass2 : public BaseClass\r\n{\r\n    // accept default definition of dFunct()\r\n};\r\n\r\nclass DerivedClass3 : public BaseClass\r\n{\r\n    // accept default definition of dFunct()\r\n};\u003c/pre\u003e\r\n\u003cp\u003eThe problem here is that there is no reasonable default behavior for derived classes. If, through error or oversight, \u003ccode\u003edFunct()\u003c/code\u003e is not redefined in \u003ccode\u003eDerivedClass1, DerivedClass2, or DerivedClass3\u003c/code\u003e, the potential dire consequences may turn real. There are several possible solutions to the problem. One possibility is to force each derived class to define the function. We do this by declaring the original function to be pure virtual:\u003c/p\u003e\r\n\u003cpre\u003eclass BaseClass\r\n{\r\npublic:\r\n    virtual int dFunct() const = 0;\r\n};\r\n\r\nclass DerivedClass1 : public BaseClass\r\n{\r\npublic:\r\n    // redefine default definition of dFunct()\r\n    virtual int dFunct() const\r\n    {\r\n        return 3;\r\n    }\r\n};\r\n\r\nclass DerivedClass2 : public BaseClass\r\n{\r\npublic:\r\n    // all subclasses must override a pure virtual function\r\n    virtual int dFunct() const\r\n    {\r\n        return 6;\r\n    }\r\n};\r\n\r\nclass DerivedClass3 : public BaseClass\r\n{\r\npublic:\r\n    // all subclasses must override a pure virtual function\r\n    virtual int dFunct() const\r\n    {\r\n        return 22;\r\n    }\r\n};\u003c/pre\u003e\r\n\u003cp\u003eSuch an action ensures that the derived class will provide a definition.\u003c/p\u003e\r\n\u003cp\u003eAlternately, we could provide a default definition in a protected area of the parent class. The derived class could access that function by simply writing\u003c/p\u003e\r\n\u003cpre\u003eBaseClass::dFunction()    // default definition \u003c/pre\u003e\r\n\u003cp\u003eSuch a function must be non-virtual or the problem is just repeated.\u003c/p\u003e\r\n\u003ch4\u003ePure Virtual Functions\u003c/h4\u003e\r\n\u003cp\u003eThe purpose of declaring a pure virtual function is to have the derived class only inherit the functional interface of the class. If a virtual function is declared pure, there is no need to supply an implementation.\u003c/p\u003e\r\n\u003cp\u003eThe basic syntax for declaring a pure virtual function is as follows:\u003c/p\u003e\r\n\u003cpre\u003evirtual returnType functionName(argsi) = 0; \u003c/pre\u003e\r\n\u003cp\u003eWhen a function is declared pure, there is no address to put into the vtable. Remember, the name of a function, like an array, is its address—we just set that address to 0. The 0 keys the compiler that no instances of this class can be created—no vtable, no instances. Before we can create instances of any classes further down the derivation chain, a definition for the function body must be provided. The first class to define such a body may have instances. That definition serves as the default in any subsequent derivations.\u003c/p\u003e\r\n\u003cp\u003eIn Example below, the function \u003ccode\u003eidentify() \u003c/code\u003eis declared pure in the base class. Thus, we cannot have instances of that class. The first derived class, class \u003ccode\u003eB\u003c/code\u003e, provides a definition and, thus, may have instances. Notice that class \u003ccode\u003eC\u003c/code\u003e chooses to override the definition.\u003c/p\u003e\r\n\u003cpre\u003e// Classes Derivation - Single Inheritance Example\r\n// Simple Inheritance - Pure Virtual Functions\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string identify() const = 0;\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    std::string identify() const\r\n    {\r\n        return \"B\";\r\n    }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    std::string identify() const\r\n    {\r\n        return \"C\";\r\n    }\r\n\r\nprivate:\r\n    int aValue;\r\n};\r\n\r\nTEST(PureVirtualFunctions, Class)\r\n{\r\n    // error - can instantiate a class with pure virtual functions\r\n    // A a;\r\n\r\n    B* b = new B;\r\n    CHECK_EQUAL(\"B\", b-\u0026gt;identify());\r\n    delete b;\r\n\r\n    b = new C;\r\n    CHECK_EQUAL(\"C\", b-\u0026gt;identify());\r\n    delete b;\r\n}\u003c/pre\u003e\r\n\u003ch3\u003eRestrictions on Pure Virtual Functions\u003c/h3\u003e\r\n\u003cp\u003eA class with one or more pure virtual functions, including those that are inherited,\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003ecan only be used as a base class;\u003c/li\u003e\r\n\u003cli\u003ecan be used as a pointer or reference type.\u003c/li\u003e\r\n\u003cli\u003ecannot have instances;\u003c/li\u003e\r\n\u003cli\u003ecannot be used as an argument type, return type, or type for explicit conversion; and\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003ch4\u003eRules for Virtual Functions\u003c/h4\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eVirtual functions called from within a constructor use the local version.\u003c/li\u003e\r\n\u003cli\u003eThe first class in a derivation hierarchy that declares a virtual function must provide a definition or must declare the virtual function to be pure.\u003c/li\u003e\r\n\u003cli\u003eIf a definition is provided, the definition serves as the default instance in subsequent derivations.\u003c/li\u003e\r\n\u003cli\u003eIf the virtual function is declared pure, a subsequently derived class must provide a definition to be able to have instances—or inherit the pure virtual function and have no instances.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003ch4\u003eAbstract Base Classes\u003c/h4\u003e\r\n\u003cp\u003eA class with one or more pure virtual functions is called an \u003cspan class=\"italics\"\u003eabstract class.\u003c/span\u003e An abstract class is not intended to be instantiated and\u003cspan class=\"bold\"\u003e cannot\u003c/span\u003e be instantiated. Their sole purpose, through a set of pure virtual functions, is to specify the interface to the class hierarchy. They decouple interfaces from the actual implementation. A typical implementation includes no data members and no constructor—no need for one, no instances.\u003c/p\u003e\r\n\u003cp\u003eThe cost of using abstract base classes is that every function call is virtual; that is, it requires an additional level of indirection. Objects derived from an abstract class must contain additional information in the form of a virtual pointer into the vtbl or virtual table. Such information is used at runtime to determine which virtual function is to be invoked. Inlining is not effective. Inlining requires access to implementation details; Abstract classes and other such classes are designed to preclude such access.\u003c/p\u003e\r\n\u003cp\u003eIf a virtual destructor is declared pure, we must provide a definition. In C++, the destructor for the most derived class is called first, and then the destructors for each derived class are called subsequently. The compiler will generate a call to the ABC destructor even though the class is abstract and so simply defines an empty body.\u003c/p\u003e\r\n\u003ch3\u003eObject Slicing\u003c/h3\u003e\r\n\u003cp\u003eWe must exercise caution when treating objects polymorphically. There is a distinct difference between passing objects by value and passing them by reference:\u003c/p\u003e\r\n\u003cpre\u003e// Classes Derivation - Single Inheritance Example\r\n// Simple Inheritance - Object Slicing\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base (int aValue = 0)\r\n        : bVal(aValue)\r\n    {\r\n    }\r\n\r\n    virtual int f() const\r\n    {\r\n        return bVal;\r\n    }\r\n\r\nprivate:\r\n    int bVal;\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n    Derived(int aVal0=0,int aVal1 = 0)\r\n        : Base(aVal0),\r\n        dVal(aVal1)\r\n    {\r\n    }\r\n\r\n    int f() const\r\n    {\r\n        return Base::f() + dVal;\r\n    }\r\n\r\nprivate:\r\n    int dVal;\r\n};\r\n\r\nint callV(Base b1)\r\n{\r\n    return b1.f();\r\n}\r\n\r\nint callR(const Base\u0026amp; b1)\r\n{\r\n    return b1.f();\r\n}\r\n\r\nTEST(ObjectSlicing, Class)\r\n{\r\n    Base b(10);\r\n    Derived d(10, 47);\r\n\r\n    CHECK_EQUAL(10, callV(b));\r\n    CHECK_EQUAL(10, callV(d));\r\n    CHECK_EQUAL(10, callR(b));\r\n    CHECK_EQUAL(57, callR(d));\r\n}\u003c/pre\u003e\r\n\u003cp\u003eNotice that, in this example, the function \u003ccode\u003ecallV()\u003c/code\u003e accepts only a \u003ccode\u003eBase\u003c/code\u003etype object. When invoked, it will cause an object of size \u003ccode\u003eBase\u003c/code\u003e to be pushed onto the stack. The compiler accepts the argument of type \u003ccode\u003eDerived\u003c/code\u003e then pushes only the \u003ccode\u003eBase\u003c/code\u003e portion onto the stack. This is not the behavior we want. Thus, always pass base classes to functions by reference, const reference, or pointer. Prefer reference when the function will modify the class and const reference when the function only need read data from the class.\u003c/p\u003e\r\n\u003ch3\u003eVirtual Base Classes\u003c/h3\u003e\r\n\u003ch4\u003eThe Need for Virtual Base Classes\u003c/h4\u003e\r\n\u003cp\u003eLet's examine a different portion of the fruit hierarchy. A nectarine is a Fruit developed by crossing a Peach and a Plum, each of which inherits from Fruit:\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384314/preview\" alt=\"inheritance from fruit\" width=\"157\" height=\"97\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384314\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eIf Fruit has a data member \u003ccode\u003estem = 1;\u003c/code\u003e, then Plum and Peach will each inherit \u003ccode\u003estem\u003c/code\u003e. Nectarine will now inherit a stem from each and now has two copies of the data member.\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"title\"\u003e\u003cspan class=\"bold\"\u003eA Nectarine with Two Stems?\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384291/preview\" alt=\"a nectarine with two stems?\" width=\"217\" height=\"157\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384291\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eThis is not a natural situation unless you happen to have gotten the Nectarine from Chernobyl. In any event, this is something we'd generally like to avoid. Theoretically, we could resolve the dilemma with the scope operator:\u003c/p\u003e\r\n\u003cpre\u003ePlum::stem;\r\nPeach::stem; \u003c/pre\u003e\r\n\u003cp\u003eThis does not represent the real world either. (A nectarine simply does not have two stems.)\u003c/p\u003e\r\n\u003cp\u003eWe solve the problem by declaring Fruit as a \u003cspan class=\"keyterm\"\u003evirtual base class\u003c/span\u003e. Such a declaration says there is only a single copy of the base class in the derivation hierarchy. This means that there is only a single copy of all inherited members. Subsequent derivations point to the shared members. This involves serious pointer magic—we're dealing with base classes implemented as pointers to objects--and is highly compiler dependent.\u003c/p\u003e\r\n\u003cp\u003eThe syntax for a including a virtual base class qualification in a class derivation is as follows:\u003c/p\u003e\r\n\u003cpre\u003eclass DerivedClassName: virtual specification BaseClassName\u003c/pre\u003e\r\n\u003cp\u003e\u003ccode\u003eDerivedClassName\u003c/code\u003e—the class being derived \u003cbr\u003e\u003ccode\u003especification\u003c/code\u003e—specifies access to the base class members\u003c/p\u003e\r\n\u003ccode\u003epublic\u003cbr\u003e protected\u003cbr\u003e private\u003cbr\u003e private by default\u003c/code\u003e\r\n\u003cp\u003ethe keyword \u003ccode\u003evirtual\u003c/code\u003e identifies \u003ccode\u003eBaseClassName\u003c/code\u003e as a virtual base class of \u003ccode\u003eDerivedClassName\u003c/code\u003e.\u003c/p\u003e\r\n\u003cp\u003eSchematically, we now have a situation that, as the figure shows, looks like more stuff for the classes to point to.\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"title\"\u003e\u003cspan class=\"bold\"\u003eVirtual Base Classes\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384305/preview\" alt=\"virtual base classes\" width=\"413\" height=\"149\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384305\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eLet's look at an example.\u003c/p\u003e\r\n\u003cpre\u003e// Classes Derivation - Multiple Inheritance Example\r\n// Simple Inheritance - Virtual Base Class\r\n\r\nclass Fruit\r\n{\r\npublic:\r\n    Fruit(\r\n        int stem = 1,\r\n        int seeds = 4)\r\n        : myStem(stem), mySeeds(seeds)\r\n    {\r\n    }\r\n\r\n    virtual std::string identify() const\r\n    {\r\n        return \"Fruit\";\r\n    }\r\n\r\n    virtual std::string skin() const = 0;\r\n\r\n    int getStem() const\r\n    {\r\n        return myStem;\r\n    }\r\n\r\nprivate:\r\n    int myStem;\r\n    int mySeeds;\r\n};\r\n\r\n//  Fruit will be a virtual base class of Plum and Peach\r\nclass Plum: public virtual Fruit\r\n{\r\npublic:\r\n    Plum()\r\n        : Fruit(2, 1)\r\n    {\r\n    }\r\n\r\n    std::string identify() const\r\n    {\r\n        return \"Plum\";\r\n    }\r\n\r\n    std::string skin() const\r\n    {\r\n        return \"Smooth\";\r\n    }\r\n};\r\n\r\nclass Peach : public virtual Fruit\r\n{\r\npublic:\r\n    Peach()\r\n        : Fruit(3, 4)\r\n    {\r\n    }\r\n\r\n    std::string identify() const\r\n    {\r\n        return \"Peach\";\r\n    }\r\n\r\n    std::string skin() const\r\n    {\r\n        return \"Fuzzy\";\r\n    }\r\n};\r\n\r\nclass Nectarine: public Plum, public Peach\r\n{\r\npublic:\r\n    Nectarine()\r\n    {\r\n    }\r\n\r\n    std::string identify() const\r\n    {\r\n        return \"Nectarine\";\r\n    }\r\n\r\n    std::string skin() const\r\n    {\r\n        return \"Smooth\";\r\n    }\r\n};\r\n\r\nTEST(virtualBaseClasses, Class)\r\n{\r\n    Nectarine *np = new Nectarine;\r\n\r\n    CHECK_EQUAL(\"Nectarine\", np-\u0026gt;identify());\r\n    CHECK_EQUAL(\"Smooth\", np-\u0026gt;skin());\r\n    CHECK_EQUAL(1, np-\u0026gt;getStem());\r\n\r\n    delete np;\r\n}\u003c/pre\u003e\r\n\u003cp\u003eSince virtual inheritance is complex, avoid it when possible. There are most always better design options.\u003c/p\u003e\r\n\u003ch4\u003eAccess Protection\u003c/h4\u003e\r\n\u003cp\u003eNow let's consider the situation shown in the hierarchy shown:\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eWhich Access Specification Dominates?\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384257/preview\" alt=\"which access specification dominates?\" width=\"272\" height=\"157\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384257\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eThere are two paths shown to D, one public and the other private. Which access specification dominates? In C++, the rule is that the most public path always dominates.\u003c/p\u003e\r\n\u003ch4\u003eVirtual Base Class Initialization\u003c/h4\u003e\r\n\u003cp\u003eNotice that in the last example the value of \u003ccode\u003estem\u003c/code\u003e is set to 3. Was this just an accident? Nope. In derivation hierarchies such as we've been looking at, which child gets to initialize the virtual base class? Simply put, the most derived class. In the example, once again, since Nectarine did not initialize the inherited member, Peach, the last specified base class does. In C++, initialization proceeds as follows:\u003c/p\u003e\r\n\u003col\u003e\r\n\u003cli\u003eConstructors for any virtual base class in the derivation hierarchy. If there are multiple virtual base classes, the constructors are invoked in the order specified on the derivation list.\u003c/li\u003e\r\n\u003cli\u003eConstructors for each non-virtual base class in the order specified in the derivation list.\u003c/li\u003e\r\n\u003cli\u003eIt is the responsibility of the most derived class to provide initialization values, via the init list, for any parameterized base class constructors.\u003c/li\u003e\r\n\u003c/ol\u003e\r\n\u003cp\u003eSpecify class E as\u003c/p\u003e\r\n\u003cpre\u003eclass E : public D, public C, public virtual F \u003c/pre\u003e\r\n\u003cp\u003eE will be the one to initialize A and F.\u003c/p\u003e\r\n\u003ch4\u003eOverride\u003c/h4\u003e\r\n\u003cp\u003eA derived class may implement a virtual function defined in the base class. This is called overriding the virtual function.  C++ supports implicit overriding. That is, if the signature of the function in the derived class matches that of the base class, the function is implicitly overridden. The following code makes use of implicit override:\u003c/p\u003e\r\n\u003cpre\u003eclass Animal\r\n{\r\npublic:\r\n    virtual void eat() = 0;\r\n};\r\n\r\nclass Dog : public Animal\r\n{\r\npublic:\r\n    // implicit override - signature matches that of the virtual function eat defined in the base class\r\n    void eat()\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"dog is eating\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n};\r\n\r\nTEST(override, Animal)\r\n{\r\n    Dog d;\r\n}\u003c/pre\u003e\r\n\u003cp\u003eThe override keyword makes explicit a derived class is implementing a virtual function declared in a base class:\u003c/p\u003e\r\n\u003cpre\u003eclass Animal\r\n{\r\npublic:\r\n    virtual void eat() = 0;\r\n};\r\n\r\nclass Dog : public Animal\r\n{\r\npublic:\r\n    // implicit override - signature matches that of the virtual function eat defined in the base class\r\n    void eat() override // explicit override\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"dog is eating\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n};\r\n\r\nTEST(override, Animal)\r\n{\r\n    Dog d;\r\n}\u003c/pre\u003e\r\n\u003cp\u003eExplicit overrides have the advantage of telling the compiler your intention. The compiler can then help you override correctly by ensuring the prerequisites for override are met. These are\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\r\n\u003cp style=\"text-align: left;\"\u003eThe base class as defined a virtual function\u003c/p\u003e\r\n\u003c/li\u003e\r\n\u003cli\u003e\r\n\u003cp style=\"text-align: left;\"\u003eThe desired derived class function override matches the signature of the virtual function exactly.\u003c/p\u003e\r\n\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp style=\"text-align: left;\"\u003eWith implicit override it can be easy to make a mistake in the signature of the virtual function in the derived class. In this case, the compiler just defines a brand new independent member function.\u003c/p\u003e\r\n\u003ch4 style=\"text-align: left;\"\u003eFinal\u003c/h4\u003e\r\n\u003cp style=\"text-align: left;\"\u003eThe final keyword is used in a derived class to signify that a function override is the final override. That is, the next derived class is not allowed to override the member function:\u003c/p\u003e\r\n\u003cpre style=\"text-align: left;\"\u003eclass Animal\r\n{\r\npublic:\r\n    virtual void eat() = 0;\r\n};\r\n\r\nclass Dog : public Animal\r\n{\r\npublic:\r\n    // implicit override - signature matches that of the virtual function eat defined in the base class\r\n    void eat() override // explicit override\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"dog is eating\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n};\r\n\r\nclass Puppy : public Dog\r\n{\r\npublic:\r\n    void eat() final \r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"puppy is eating\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n};\r\n\r\nclass HappyPuppy : public Puppy\r\n{\r\npublic:\r\n    void eat() // compiler error - eat declared as final in Puppy\r\n    {\r\n        std::cout \u0026lt;\u0026lt; \"puppy is eating\" \u0026lt;\u0026lt; std::endl;\r\n    }\r\n};\r\n\r\nTEST(override, Animal)\r\n{\r\n    Dog d;\r\n}\u003c/pre\u003e\r\n\u003cp style=\"text-align: left;\"\u003eFinal is used to enforce design.\u003c/p\u003e\r\n\u003ch3\u003eSummary\u003c/h3\u003e\r\n\u003cp\u003eIn this lesson, we introduced the concept of runtime polymorphism and discussed its implementation in C++ through virtual functions and late binding. We then moved inside the class structure to look at the mechanics of how such a scheme is implemented using vpointers and the vtable. We concluded with pure virtual functions, abstract base classes, virtual base classes, and the problem of object slicing.\u003c/p\u003e\r\n\u003ch3\u003ePractice Questions\u003c/h3\u003e\r\n\u003cp\u003eTest your understanding of the concepts in Lesson 10 by working through the following practice questions, then check your answers with \u003ca id=\"\" class=\"\" title=\"Answers to Practice Questions for Lesson 10\" href=\"https://canvas.uw.edu/courses/1177926/pages/answers-to-practice-questions-for-lesson-10\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/pages/answers-to-practice-questions-for-lesson-10\" data-api-returntype=\"Page\"\u003eAnswers to Practice Questions for Lesson 10\u003c/a\u003e.\u003c/p\u003e\r\n\u003col\u003e\r\n\u003cli\u003eHow is polymorphism implemented in C++?\u003c/li\u003e\r\n\u003cli\u003eWhat is the purpose of an abstract base class (ABC)?\u003c/li\u003e\r\n\u003cli\u003eHow is a virtual function declared?\u003c/li\u003e\r\n\u003cli\u003eCan a virtual function be overloaded?\u003c/li\u003e\r\n\u003cli\u003eHow is a virtual function invoked?\u003c/li\u003e\r\n\u003cli\u003eWhy should you use a virtual destructor?\u003c/li\u003e\r\n\u003cli\u003eHow do we declare a pure virtual function?\u003c/li\u003e\r\n\u003cli\u003eWhy should a derived class object be passed to a function expecting a base class object by reference rather than by value?\u003c/li\u003e\r\n\u003c/ol\u003e\r\n"},"WIKI_PAGE_REVISION":"2","WIKI_PAGE_SHOW_PATH":"/courses/1177926/pages/lesson-10","WIKI_PAGE_EDIT_PATH":"/courses/1177926/pages/lesson-10/edit","WIKI_PAGE_HISTORY_PATH":"/courses/1177926/pages/lesson-10/revisions","COURSE_ID":"1177926","MODULES_PATH":"/courses/1177926/modules","wiki_page_menu_tools":[],"DISPLAY_SHOW_ALL_LINK":false,"STUDENT_PLANNER_ENABLED":true,"badge_counts":{"submissions":0},"notices":[]};
</script>

<script src="./Lesson 10_files/navigation_header.bundle-549b1681b9.js" defer="defer"></script>
<script src="./Lesson 10_files/default.js" defer="defer"></script>
<script src="./Lesson 10_files/custom.js" defer="defer"></script>

</div> <!-- #application -->


<div id="nav-tray-portal" style="position: relative; z-index: 99;"></div></body></html>