<!DOCTYPE html>
<!-- saved from url=(0075)https://canvas.uw.edu/courses/1177926/pages/lesson-4?module_item_id=7889528 -->
<html class="lato-font-loaded" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Lesson 4: CPROGRM 711 A Wi 18: C++ Programming: Introduction</title>
  <!--[if lte IE 9]> <meta http-equiv=refresh content="0; URL=/ie-9-is-not-supported.html" /> <![endif]-->
  <link rel="shortcut icon" type="image/x-icon" href="https://instructure-uploads.s3.amazonaws.com/account_100000000083919/attachments/37312004/favicon.ico?AWSAccessKeyId=AKIAJFNFXH2V2O7RPCAA&amp;Expires=1939374366&amp;Signature=lNl7iuCda9spDgRONbwVvr490LM%3D&amp;response-cache-control=Cache-Control%3Amax-age%3D473364000.0%2C%20public&amp;response-expires=473364000.0">
  <link rel="apple-touch-icon" href="https://instructure-uploads.s3.amazonaws.com/account_100000000083919/attachments/37312005/Canvas-MobileHome.png?AWSAccessKeyId=AKIAJFNFXH2V2O7RPCAA&amp;Expires=1939374366&amp;Signature=jwVDIJvM6uIaOoE%2FSW94uwVcHU0%3D&amp;response-cache-control=Cache-Control%3Amax-age%3D473364000.0%2C%20public&amp;response-expires=473364000.0">
  
  <link rel="stylesheet" media="all" href="./Lesson4_files/variables-750d72b9d3e5d522f965bf904110c132.css">
  <link rel="stylesheet" media="all" href="./Lesson4_files/common-79b981d2d9.css">
  <script type="text/javascript" async="" src="./Lesson4_files/ga.js.download"></script><script>
//<![CDATA[

!function(){
  var o,s,v;
  if (!(window.Promise && Object.assign && Object.values && [].find && [].includes && (o={},s=Symbol(),v={},o[s]=v,o[s]===v) && (function f(){}).bind().name==='bound f')) {
    s = 's', document.write('<'+s+'cr'+'ipt src="https://du11hjcvx0uqb.cloudfront.net/dist/ie11-polyfill-a0702bf7af.js"></'+s+'c'+'ript>');
  }
}();
      
//]]>
</script>
  <script src="./Lesson4_files/lato-fontfaceobserver-11a14bc0b6.js.download" async="async"></script>
  
  <meta name="apple-itunes-app" content="app-id=480883488">
<link rel="manifest" href="https://canvas.uw.edu/web-app-manifest/manifest.json">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#008EE2">
  <link rel="stylesheet" media="all" href="./Lesson4_files/wiki_page-46e7e026f6.css">
  
  <link rel="stylesheet" media="all" href="./Lesson4_files/custom.css">
<link rel="stylesheet" media="all" href="./Lesson4_files/custom(1).css">
  <script>
    function _earlyClick(e){
      var c = e.target
      while (c && c.ownerDocument) {
        if (c.getAttribute('href') == '#' || c.getAttribute('data-method')) {
          e.preventDefault()
          (_earlyClick.clicks = _earlyClick.clicks || []).push(c)
          break
        }
        c = c.parentNode
      }
    }
    document.addEventListener('click', _earlyClick)
  </script>
  <script src="./Lesson4_files/variables-750d72b9d3e5d522f965bf904110c132.js.download" defer="defer"></script>
  <script src="./Lesson4_files/vendor.bundle-128d24e8f6.js.download" defer="defer"></script>
<script src="./Lesson4_files/Los_Angeles-78b0e93740.js.download" defer="defer"></script>
<script src="./Lesson4_files/en_US-80a0ce259b.js.download" defer="defer"></script>
<script src="./Lesson4_files/appBootstrap.bundle-659e6cb04a.js.download" defer="defer"></script>
<script src="./Lesson4_files/common.bundle-7a4babf662.js.download" defer="defer"></script>
<script src="./Lesson4_files/wiki_page_show.bundle-6cdff07d81.js.download" defer="defer"></script>
<style type="text/css"></style></head>

<body class="with-left-side course-menu-expanded padless-content pages primary-nav-transitions context-course_1177926 show webkit chrome touch">

<noscript>
  &lt;div role="alert" class="ic-flash-static ic-flash-error"&gt;
    &lt;div class="ic-flash__icon" aria-hidden="true"&gt;
      &lt;i class="icon-warning"&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;h1&gt;You need to have JavaScript enabled in order to access this site.&lt;/h1&gt;
  &lt;/div&gt;
</noscript>





<ul id="flash_message_holder"></ul>
<div id="flash_screenreader_holder" role="alert" aria-live="assertive" aria-relevant="additions" class="screenreader-only" aria-atomic="false"></div>

<div id="application" class="ic-app">
  
  <header id="header" class="ic-app-header no-print ">
    <a href="https://canvas.uw.edu/courses/1177926/pages/lesson-4?module_item_id=7889528#content" id="skip_navigation_link">Skip To Content</a>
      <div role="region" class="ic-app-header__main-navigation" aria-label="Global Navigation">
        <div class="ic-app-header__logomark-container">
          <a href="https://canvas.uw.edu/" class="ic-app-header__logomark">
            <span class="screenreader-only">Dashboard</span>
          </a>
        </div>
        <ul id="menu" class="ic-app-header__menu-list">
            <li class="menu-item ic-app-header__menu-list-item ">
              <a id="global_nav_profile_link" href="https://canvas.uw.edu/profile" class="ic-app-header__menu-list-link">
                <div class="menu-item-icon-container" aria-hidden="true">
                  <div class="ic-avatar ">
                    <img src="./Lesson4_files/mSs2TjTESYscSzrackhgoJvAT79xbNchamHPrSec" alt="Clayton Wong">
                  </div>
                </div>
                <div class="menu-item__text">
                  Account
                </div>
              </a>
            </li>
          <li class="ic-app-header__menu-list-item ">
            <a id="global_nav_dashboard_link" href="https://canvas.uw.edu/" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                  <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--dashboard" version="1.1" x="0" y="0" viewBox="0 0 280 200" enable-background="new 0 0 280 200" xml:space="preserve"><path d="M273.09,180.75H197.47V164.47h62.62A122.16,122.16,0,1,0,17.85,142a124,124,0,0,0,2,22.51H90.18v16.29H6.89l-1.5-6.22A138.51,138.51,0,0,1,1.57,142C1.57,65.64,63.67,3.53,140,3.53S278.43,65.64,278.43,142a137.67,137.67,0,0,1-3.84,32.57ZM66.49,87.63,50.24,71.38,61.75,59.86,78,76.12Zm147,0L202,76.12l16.25-16.25,11.51,11.51ZM131.85,53.82v-23h16.29v23Zm15.63,142.3a31.71,31.71,0,0,1-28-16.81c-6.4-12.08-15.73-72.29-17.54-84.25a8.15,8.15,0,0,1,13.58-7.2c8.88,8.21,53.48,49.72,59.88,61.81a31.61,31.61,0,0,1-27.9,46.45ZM121.81,116.2c4.17,24.56,9.23,50.21,12,55.49A15.35,15.35,0,1,0,161,157.3C158.18,152,139.79,133.44,121.81,116.2Z"></path></svg>

              </div>
              <div class="menu-item__text">Dashboard</div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ic-app-header__menu-list-item--active">
            <a id="global_nav_courses_link" href="https://canvas.uw.edu/courses" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--courses" version="1.1" x="0" y="0" viewBox="0 0 280 259" enable-background="new 0 0 280 259" xml:space="preserve"><path d="M73.31,198c-11.93,0-22.22,8-24,18.73a26.67,26.67,0,0,0-.3,3.63v.3a22,22,0,0,0,5.44,14.65,22.47,22.47,0,0,0,17.22,8H200V228.19h-134V213.08H200V198Zm21-105.74h90.64V62H94.3ZM79.19,107.34V46.92H200v60.42Zm7.55,30.21V122.45H192.49v15.11ZM71.65,16.71A22.72,22.72,0,0,0,49,39.36V190.88a41.12,41.12,0,0,1,24.32-8h157V16.71ZM33.88,39.36A37.78,37.78,0,0,1,71.65,1.6H245.36V198H215.15v45.32h22.66V258.4H71.65a37.85,37.85,0,0,1-37.76-37.76Z"></path></svg>

              </div>
              <div class="menu-item__text">
                Courses
              </div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ">
            <a id="global_nav_calendar_link" href="https://canvas.uw.edu/calendar" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--calendar" version="1.1" x="0" y="0" viewBox="0 0 280 280" enable-background="new 0 0 280 280" xml:space="preserve"><path d="M197.07,213.38h16.31V197.07H197.07Zm-16.31,16.31V180.76h48.92v48.92Zm-48.92-16.31h16.31V197.07H131.85Zm-16.31,16.31V180.76h48.92v48.92ZM66.62,213.38H82.93V197.07H66.62ZM50.32,229.68V180.76H99.24v48.92Zm146.75-81.53h16.31V131.85H197.07Zm-16.31,16.31V115.54h48.92v48.92Zm-48.92-16.31h16.31V131.85H131.85Zm-16.31,16.31V115.54h48.92v48.92ZM66.62,148.15H82.93V131.85H66.62ZM50.32,164.46V115.54H99.24v48.92ZM34,262.29H246V82.93H34ZM246,66.62V42.16A8.17,8.17,0,0,0,237.84,34H213.38v8.15a8.15,8.15,0,1,1-16.31,0V34H82.93v8.15a8.15,8.15,0,0,1-16.31,0V34H42.16A8.17,8.17,0,0,0,34,42.16V66.62Zm-8.15-48.92a24.49,24.49,0,0,1,24.46,24.46V278.6H17.71V42.16A24.49,24.49,0,0,1,42.16,17.71H66.62V9.55a8.15,8.15,0,0,1,16.31,0v8.15H197.07V9.55a8.15,8.15,0,1,1,16.31,0v8.15Z"></path></svg>

              </div>
              <div class="menu-item__text">
                Calendar
              </div>
            </a>
          </li>
          <li class="menu-item ic-app-header__menu-list-item ">
            <a id="global_nav_conversations_link" href="https://canvas.uw.edu/conversations" class="ic-app-header__menu-list-link">
              <div class="menu-item-icon-container" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--inbox" version="1.1" x="0" y="0" viewBox="0 0 280 280" enable-background="new 0 0 280 280" xml:space="preserve"><path d="M91.72,120.75h96.56V104.65H91.72Zm0,48.28h80.47V152.94H91.72Zm0-96.56h80.47V56.37H91.72Zm160.94,34.88H228.52V10.78h-177v96.56H27.34A24.17,24.17,0,0,0,3.2,131.48V244.14a24.17,24.17,0,0,0,24.14,24.14H252.66a24.17,24.17,0,0,0,24.14-24.14V131.48A24.17,24.17,0,0,0,252.66,107.34Zm0,16.09a8.06,8.06,0,0,1,8,8v51.77l-32.19,19.31V123.44ZM67.58,203.91v-177H212.42v177ZM27.34,123.44H51.48v79.13L19.29,183.26V131.48A8.06,8.06,0,0,1,27.34,123.44ZM252.66,252.19H27.34a8.06,8.06,0,0,1-8-8V202l30,18H230.75l30-18v42.12A8.06,8.06,0,0,1,252.66,252.19Z"></path></svg>

                <span class="menu-item__badge" style="display: none">0</span>
              </div>
              <div class="menu-item__text">
                Inbox
              </div>
            </a>
          </li>
            


          <li class="ic-app-header__menu-list-item">
           <a id="global_nav_help_link" class="ic-app-header__menu-list-link" data-track-category="help system" data-track-label="help button" href="http://help.instructure.com/">
              <div class="menu-item-icon-container" role="presentation">
                <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg menu-item__icon svg-icon-help" version="1.1" x="0" y="0" viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" fill="currentColor"><path d="M100,127.88A11.15,11.15,0,1,0,111.16,139,11.16,11.16,0,0,0,100,127.88Zm8.82-88.08a33.19,33.19,0,0,1,23.5,23.5,33.54,33.54,0,0,1-24,41.23,3.4,3.4,0,0,0-2.74,3.15v9.06H94.42v-9.06a14.57,14.57,0,0,1,11.13-14,22.43,22.43,0,0,0,13.66-10.27,22.73,22.73,0,0,0,2.31-17.37A21.92,21.92,0,0,0,106,50.59a22.67,22.67,0,0,0-19.68,3.88,22.18,22.18,0,0,0-8.65,17.64H66.54a33.25,33.25,0,0,1,13-26.47A33.72,33.72,0,0,1,108.82,39.8ZM100,5.2A94.8,94.8,0,1,0,194.8,100,94.91,94.91,0,0,0,100,5.2m0,178.45A83.65,83.65,0,1,1,183.65,100,83.73,83.73,0,0,1,100,183.65" transform="translate(-5.2 -5.2)"></path></svg>

              </div>
              <div class="menu-item__text">
                Help
              </div>
</a>          </li>
        </ul>
      </div>
      <div class="ic-app-header__secondary-navigation">
        <ul class="ic-app-header__menu-list">
          <li class="menu-item ic-app-header__menu-list-item">
            <button id="primaryNavToggle" class="ic-app-header__menu-list-link ic-app-header__menu-list-link--nav-toggle" aria-label="
                Expand global navigation
                " title="
                Expand global navigation
                ">
              <svg xmlns="http://www.w3.org/2000/svg" class="ic-icon-svg ic-icon-svg--navtoggle" version="1.1" x="0" y="0" width="40" height="32" viewBox="0 0 40 32" xml:space="preserve">
  <path d="M39.5,30.28V2.48H37.18v27.8Zm-4.93-13.9L22.17,4,20.53,5.61l9.61,9.61H.5v2.31H30.14l-9.61,9.61,1.64,1.64Z"></path>
</svg>

            </button>
          </li>
        </ul>
      </div>
    <div id="global_nav_tray_container"><noscript data-reactid=".0"></noscript></div>
  </header>


  <div id="instructure_ajax_error_box">
    <div style="text-align: right; background-color: #fff;"><a href="https://canvas.uw.edu/courses/1177926/pages/lesson-4?module_item_id=7889528#" class="close_instructure_ajax_error_box_link">Close</a></div>
    <iframe id="instructure_ajax_error_result" src="./Lesson4_files/saved_resource.html" style="border: 0;" title="Error"></iframe>
  </div>

  

  <div id="wrapper" class="ic-Layout-wrapper">
      <div class="ic-app-nav-toggle-and-crumbs no-print">
          <button type="button" id="courseMenuToggle" class="Button Button--link ic-app-course-nav-toggle" aria-live="polite" aria-label="Hide Courses Navigation Menu" title="Hide Courses Navigation Menu">
            <i class="icon-hamburger" aria-hidden="true"></i>
          </button>
          <div class="ic-app-crumbs">
        <nav id="breadcrumbs" role="navigation" aria-label="breadcrumbs"><ul><li class="home"><a href="https://canvas.uw.edu/"><span class="ellipsible">      <i class="icon-home" title="My Dashboard">
        <span class="screenreader-only">My Dashboard</span>
      </i>
</span></a></li><li><a href="https://canvas.uw.edu/courses/1177926"><span class="ellipsible">CPROGRM 711 A</span></a></li><li><a href="https://canvas.uw.edu/courses/1177926/pages"><span class="ellipsible">Pages</span></a></li><li><span class="ellipsible">Lesson 4</span></li></ul></nav>
        </div>
      </div>
    <div id="main" class="ic-Layout-columns">
        <div class="ic-Layout-watermark"></div>
        <div id="left-side" class="ic-app-course-menu list-view" style="display: block">
              <span id="section-tabs-header-subtitle" class="ellipsis">Winter 2018</span>
            <nav role="navigation" aria-label="Courses Navigation Menu"><ul id="section-tabs"><li class="section"><a href="https://canvas.uw.edu/courses/1177926" title="Home" class="home" tabindex="0">Home</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/announcements" title="Announcements" class="announcements" tabindex="0">Announcements</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/modules" title="Modules" class="modules" tabindex="0">Modules</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/discussion_topics" title="Discussions" class="discussions" tabindex="0">Discussions</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/grades" title="Grades" class="grades" tabindex="0">Grades</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/users" title="People" class="people" tabindex="0">People</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/external_tools/12299" title="UW Libraries" class="context_external_tool_12299" tabindex="0">UW Libraries</a></li><li class="section"><a href="https://canvas.uw.edu/courses/1177926/external_tools/57145" title="Info &amp; Help" class="context_external_tool_57145" tabindex="0">Info &amp; Help</a></li></ul></nav>
        </div>
      <div id="not_right_side" class="ic-app-main-content">
        <div id="content-wrapper" class="ic-Layout-contentWrapper">
            

          <div id="content" class="ic-Layout-contentMain" role="main">
            

  

<div id="wiki_page_show">
<div class="header-bar-outer-container">
  <div class="header-bar-container sticky-toolbar" data-sticky="">
    <div class="header-bar flex-container">
      <div class="header-bar-left header-left-flex">
        
          
        
      </div>
      <div class="header-bar-right header-right-flex">
        
          
          
            
          
        
        
          
        
        
      </div>
    </div>
    <div class="page-changed-alert" role="alert" aria-atomic="true" aria-live="polite"></div>
  </div>
</div>


<div class="show-content user_content clearfix enhanced">
  <h1 class="page-title">Lesson 4</h1>
  
    <div id="level2">
<h1>
<img src="./Lesson4_files/preview" alt="L04.png" width="50" height="50" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384337" data-api-returntype="File" style="max-width: 945px;">&nbsp;A Tour of C++ - Object concepts - UML Class Diagrams</h1>
<h3>Design, Development, and Test</h3>
<h4>Thinking in Models</h4>
<p>Software systems are becoming increasingly complicated and difficult to develop. Today even small systems tend to exhibit much greater capabilities and increasing numbers of features. Thus, we are continually striving to devise ways to attack complexity (it seems to be winning sometimes). One such method is to develop and use <span class="keyterm">models </span>to try to abstract away the inessential details and focus on what's important. Models are simplifications of a problem—an abstract representation of a real-world entity. Objects, too, are an abstraction, a model. As we learned, they encapsulate data and the functions that operate on the data.</p>
<p>At this point, it's a fair question to ask what makes a good model. First, it must be simple. It must be accurate. It must support abstraction and refinement. Finally, it must be extensible.</p>
<h3>Objects and the Object Model</h3>
<p>We'll begin our study of objects and the object model by examining the process of solving problems and thinking about some of the things that are important . . . hold on here, it's important tell a little bit more about what an object is.</p>
<p>Fair enough. Certainly one of the first questions that people new to object centered design ask is: "What is an object?" So, let's see.</p>
<p>An object is any thing—either tangible or conceptual—that is a part of the problem domain of the software you are developing. Objects have three fundamental characteristics: <span class="italics">identity</span>, <span class="italics">state</span>, and <span class="italics">behavior</span>. A significant part of object oriented analysis is the identification of the objects in the problem domain. So, how do you know when something in your problem domain is an object? A good place to start is in the requirements document (we'll learn how to write this in a future lesson—it's basically a description of what the customer wants). As you read the requirements, look for nouns: the people, places, things, and concepts. Each is a potential object and each will have identity, state, and behavior.</p>
<h4>Object Identity</h4>
<p>Identity is what distinguishes an object from all other objects in a software system. This may mean that it has a unique name, or that it has some other way of being uniquely identified within a program (such as a numeric identifier), or a unique position within some container of objects.</p>
<h4>Object State</h4>
<p>Objects have attributes. For example, an apple is red, green, yellow, or some mixture of these three colors. Apples also have shape, size, and weight attributes. The current value of all these attributes for a particular apple is called its state. In the object world, an object always knows its own state, and it may change that state in response to the occurrence of events or to messages it gets from other objects.</p>
<h4>Object Behavior</h4>
<p>Objects exhibit behavior by responding to events or to messages from other objects. In C++ these messages take the form of a function call. These messages may be queries about an object's current state, requests for it to change its state, or requests for the object to perform some service.</p>
<p>To see how these concepts might apply, let's propose that we have a display that is showing a variety of different geometric shapes. Let's make several of them rectangles. When we want to move a Rectangle class object from one place to another, we first have to identify which Rectangle we want to move. We then send it the <span class="italics">move</span> message with some data that tell it where we want it to move on the screen. This is a pretty complex piece of behavior, and to achieve it, the object will execute three other, simpler pieces of behavior: <span class="italics">erase, set the new position</span>, and <span class="italics">draw</span>. Another way of looking at this process is as just a change in the state of the Rectangle; erasing makes it invisible, moving it changes its position, and drawing makes it visible. We will learn much more about the interrelationship of <span class="italics">object state</span> and behavior in later lessons.</p>
<h3>Class</h3>
<p>In C++ objects are implemented using classes. A class is similiar to a C struct in that the class contains data members. For example, an employee class might look like:</p>
<pre>class Employee
{
    std::string firstName;
    std::string lastName
};</pre>
<p>A class may also contain member functions that have access to the member data. Calling a member function on a class is how we send a message to a C++ object. We'll get into more details of class in later lessons.</p>
<h3>Instance</h3>
<p>In C++ an instance is a variable of a particular class. When the variable is created it is said that it is "instantiated". Here we instantiate two Employee class instances:</p>
<pre>Employee janitor;
Employee ceo;</pre>
<p>janitor is an instance of class Employee, and ceo is another instance of class Employee. We can also call these instances objects. A C++ developer might say I've got an Employee object, or the developer might see I've got an Employee instance. Both phrases have the same meaning.</p>
<h3>Object Oriented Design and C++</h3>
<p>To most effectively use C++ we must understand Object Oriented analysis and design. Throughout this course and the entire C++ certificate program we will study Object Oriented analysis and design hand in hand with our learning and use of C++. We will first learn object oriented concepts (such as inheritance) before we attempt to implement these concepts in C++. Object oriented analysis and design came before C++. So first we'll attempt to get a good grasp on these OO concepts. Learning C++ will then be simpler. We'll be saying Oh, that's how C++ does data hiding, or Oh, that's how C++ does inheritance.</p>
<p>The OO analysis and OO design would be the same (or almost the same) regardless of the language we chose to implement those concepts. So in this lesson the focus is on OO concepts and design. Through the remainder of the course we will then focus on how to implement these OO concepts in C++.</p>
<p>What is the advantage of programming with objects versus the programming without objects? One way to answer this is with an example. In C strings are implemented as arrays of characters. To manipulate strings in C we must write code that knows many of the details of how strings are implemented. We must allocate and deallocate memory. We must ensure the string is terminated with a null character. We must recognize the difference between operating on the string, and operating on the pointer that holds the address of the string. We must make sure we follow all the rules correctly with the string to ensure there are no bugs. We must do this over and over again in C for each string we use. When you look at C code that manipulates strings the code that manipulates strings often times makes it hard to see the higher level business rules the code is implemented versus the lower level details of string manipulation</p>
<p>In C++ we use the std::string object. The lower level details of manipulating the string are hidden from us. These details include allocating memory, copying characters, comparing them to other string and other operations. These low level details are implemented once within the string class. We can use these details over and over again without continually reimplementing them. The amount of code required for us to manipulate a std::string is much less. In C++ we program at a higher level with std::string. As a result in C++ code (when well written) it is much easier to look at the code and see what it is trying to accomplish without getting lost in the low level details of string manipulation.</p>
<h4>Problem Solving</h4>
<p>When we begin the design of a new product or need to incorporate several new features into an existing one, we begin with a set of requirements usually stated in English. Our goal is to map those requirements—the real world—through a series of transformations into a solution—the abstract world. We see this process reflected in Figure 1.1, below.</p>
<p>During the design process, we move from the concrete, real world into the abstract. At the <span class="italics">Application</span> level, entities in the problem statement are abstracted into types. At the <span class="italics">Solution</span> level, these entities become our objects. We abstract these into classes.</p>
<p class="title"><span class="bold">Figure 1.1—Concrete versus Abstract</span></p>
<p><a title="Concrete versus Abstract" href="./Lesson4_files/preview(1)" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384312" data-api-returntype="File"><img src="./Lesson4_files/preview(1)" alt="concrete vs. abstract" width="369" height="163" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384312" data-api-returntype="File" style="max-width: 945px;"></a></p>
<p>Let's consider a simple problem. Our mom said, "You're such a slob, get some culture." Since we always listen to mom, we decide to go start a business making yogurt. When making yogurt in large batches (batch processing, of course), we need to have the proper temperature throughout the mixture. If the temperature is too low the cultures may not grow and if too hot, the wee beasties may die. Thus, we see we need to be able to measure temperature . . . an <span class="italics">entity</span>. Because we're growing the yogurt in a large vat, we'll need to measure the temperature at several different locations . . . ah ha, another <span class="italics">entity</span>. We now abstract both of these to floating point numbers, the <span class="italics">types</span>. In application space, we now have our <span class="italics">entities</span> and our <span class="italics">types</span>.</p>
<p>Meanwhile, over in the solution space, we have temperature objects and location objects which we will abstract to <span class="italics">Temperature</span> and <span class="italics">Location</span> classes. If we were to design such a system, we'd probably create a parent class called <span class="italics">YogurtTemp</span> or some such thing. Such a class would have at least two data members: the temperature and the location within the vat where the temperature was measured.</p>
<p>With this brief introduction, we begin with the question, <span class="italics">Can you think in Objects?</span></p>
<h4>Thinking in Objects</h4>
<p>To start thinking in objects, let's first define some terms.</p>
<ul>
<li>
<span class="keyterm">Object-oriented Programming</span> is a method of implementation in which a program is organized as a co-operative collection of objects. Each such object represents an instance of some class. Within the program, the classes may be members of a hierarchy of classes, united via inheritance relationships. This is the approach we will use as we begin to explore the design process. Often, we'll use aggregation (collecting things together) rather that inheritance, though.</li>
<li>
<span class="keyterm">Object-oriented Requirements</span> is a method of analysis that captures the behavioral requirements of a system.</li>
<li>
<span class="keyterm">Object-oriented Design</span> is a method of design encompassing the process of object-oriented decomposition and a notation for depicting logical and physical models of system.</li>
</ul>
<p>When doing object-centered design, we will often use the <span class="italics">Unified Modeling Language</span> (UML) as our modeling notation and one of our tools. We'll study UML throughout this course.</p>
<p><span class="keyterm">Object-oriented Analysis</span> is a method of analysis that examines the requirements of the problem from perspective of (entities) objects and classes that are found in the vocabulary of the problem domain.</p>
<p>When we analyze a problem, the vocabulary of the problem domain is where we look for the nouns, verbs, adjectives, and adverbs that will become our objects, actions, and object properties. We will use the CRC card (Classes, Responsibilities, Collaborators) method which is one common approach for object discovery.</p>
<h3>Class-responsibility-collaboration cards (CRC cards)</h3>
<p>Class Responsibility Collaboration (CRC) cards are a brainstorming tool used in the design of object-oriented software. They were proposed by Ward Cunningham and Kent Beck. [1] They are typically used when first determining which classes are needed and how they will interact.</p>
<p>CRC cards are usually created from index cards on which are written:</p>
<ol>
<li>The class name</li>
<li>Its Super and Sub classes (if applicable)</li>
<li>The responsibilities of the class.</li>
<li>The names of other classes with which the class will collaborate to fulfill its responsibilities.</li>
<li>Author</li>
</ol>
<p>Using a small card keeps the complexity of the design at a minimum. It focuses the designer on the essentials of the class and prevents her/him from getting into its details and inner workings at a time when such detail is probably counter-productive. It also forces the designer to refrain from giving the class too many responsibilities. Because the cards are portable, they can easily be laid out on a table and re-arranged while discussing a design with other people.</p>
<p>A common method to determine what cards should be created is to read a specification for the program being designed and consider if each noun should be a class and if each verb should be a responsibility of the noun or class to which it belongs. Naturally, the existence of a noun or verb does not require a class or responsibility in the program, but it is considered a good starting point.</p>
<h3>The Object Model</h3>
<p>In the opening of this lesson, we've identified several of the more common programming styles, classified by how data and functions are encapsulated. We've learned that in the object-centered style, the means of encapsulation is objects. Clearly, there is no single method that is the best for every problem and every application. Each of these programming paradigms has its strengths and weaknesses. Each has its own conceptual framework. Each requires its own way of thinking about the problem. For the object-centered style, the framework is the <span class="italics">object model</span>. When we move inside the object, we find the model comprises four major elements and three minor ones. The major elements include <span class="italics">abstraction, encapsulation, modularity</span>, and <span class="italics">hierarchy</span>. The minor elements consist of <span class="italics">typing, concurrency,</span> and <span class="italics">persistence</span>. We will examine each of these.</p>
<h4>Abstraction</h4>
<p><span class="keyterm">Abstraction</span> is an effective means of dealing with complexity. When we abstract something, we focus on its outside view . . . on its outside behavior . . . how others perceive it. An abstraction identifies those essential characteristics of the object that distinguish it from all other objects. The abstraction defines crisp conceptual boundaries. A good abstraction emphasizes details that are significant and suppresses those that are not. In designing objects, we identify two main kinds of abstraction: <span class="italics">entity</span> and<span class="italics"> action</span>.</p>
<p>With <span class="keyterm">entity abstraction</span>, we develop objects or models that represent elements in the problem domain. Such models, usually nouns, directly parallel the vocabulary of that domain. These may represent a linked list, electronic part, display device, or file system. At this level, we make no statement about how such an object is implemented.</p>
<p><span class="keyterm">Action abstraction</span>(or action objects)<span class="italics">, </span>based upon the verbs in the problem domain, provides a generalized set of operations that all perform the same kind of function. Such actions may include inserting, copying, moving, sorting, or searching.</p>
<h4>Encapsulation</h4>
<p><span class="italics">Encapsulation</span> is a complement to abstraction. Encapsulation is grouping data and functions that operate on that data together. In C++ objects have both data and functions that operate on that data. The data and functions are encapsulated using the C++ class. The data associated with a class is called "member data". Functions that operate on that data and that are associated with the class are called "member functions". Member is used as in "member" of the class.</p>
<h4>Information Hiding</h4>
<p>In object-centered design, we look at an object as a "black box." It must have a public interface that permits the user of instances of the object to access the object. At the same time, it does not give access to the internals of the object. The internals are kept private. In other words the private data is "hidden". Encapsulation provides explicit barriers among abstractions; it is the process of compartmentalizing elements of an abstraction. Its structure serves to separate the constructional interface from the implementation.</p>
<p>When we use information hiding, we want to make certain inessential and unnecessary details inaccessible. Our motive is to reduce the number of details that we need to deal with. We want the interaction among objects to be as simple as possible, to reduce the chances of incorrect or unintended interactions or mistakes. Thus, encapsulation helps reduce the chances of system corruption. That is, a change in one area does not result in unanticipated change in another.</p>
<p>Consider, for example a bank account. We can make deposits or withdrawals or enquire about our balance, using a teller, a bank machine, or a telephone. We do not have to have knowledge about how such operations are accomplished or changed, presuming they're done correctly (although, looking at some of today's banking, we may want to pay a bit more attention).</p>
<h4>Polymorphism</h4>
<p>Polymorphism means that some code or operations or objects behave differently when responding to the same message. For example, the + (plus) operator in C++ performs different operations depending on the data type it is applied to:</p>
<pre>4 + 5       &lt;-- integer="" addition="" 3="" 14="" 2="" 0="" --="" floating="" point="" s1="" bar="" string="" concatenation="" pre=""&gt;</pre>
<p>This type of polymorphism is called overloading.</p>
<p>Typically, when the term polymorphism is used with C++, however, it refers to using virtual methods. A virtual method is defined in a base class, but the implementation (i.e., code) is provided in the derived class. A classic example is an Drawable base class with a polymorphic method draw(). Both a Circle and Square subclass Drawable. Circle::draw draws a circle, while Square::draw() draws a square. Note we have also introduced the :: operator. :: is called the scope resolution operator and is used to determine which draw method is being referenced in the code.</p>
<h4>Modularity</h4>
<p>Modularity is the act of partitioning a program into individual components to reduce complexity. The modules serve as physical containers and declare the classes and objects of the logical design. Modularity describes a system that has been decomposed into a set of cohesive <span class="keyterm">loosely coupled</span> modules. "Loosely coupled" is the key phrase here. We want to localize the effect of changes. A common problem among some of my beginning students is this lament: "But I never changed anything near there! Why did that suddenly break?" Ahhh, they'll learn, they'll learn, as they gain more experience . . . but do they listen now?</p>
<p>We must consider several things about modularity.</p>
<ul>
<li>First, modules serve as elementary, indivisible units of software or hardware; this is still a consideration in object-oriented design. We try to package classes and objects to promote reuse. When we begin to design something, we must always remember to look to the next project. Ask questions like, "How can we modify our current design to support a future feature?" This is where the marketing and sales people really help us.</li>
<li>Second, many compilers generate object code in segments, one for each module. Such actions may place size restrictions on the individual modules. Poor module builds can significantly affect memory access, increase cache misses, and promote thrashing.</li>
<li>Third, when modularizing a design, we should consider work assignments. Often, such assignments are made module by module. We should consider defining module boundaries so as to minimize interfaces among different parts of the organization. Such a practice simplifies the process of subcontracting some of the work as well. It also lets experienced people keep the good stuff and give the mundane—I mean, opportunities to learn!—to the new designers.</li>
<li>Fourth, we should package the modules with the goal of stabilizing the module interfaces during the early part of the design. We'll talk about how we approach this shortly.</li>
<li>Finally, when modularizing a design, we need to consider security issues. Whether working for a toy company or on a sensitive government project, we need to consider what information we make available to outside vendors. By properly decomposing a system, we can more easily select which portion we want to farm out and which we need to retain control over.</li>
</ul>
<h4>Inheritance</h4>
<p>An object can inherit member functions, member data, and member function signatures (i.e., interface) from another class. A class that inherits from another class is called a subclass or derived class. A class that is inherited from is called a superclass or base class. There are 3 basic inheritance types:</p>
<ol>
<li>Implementation inheritance - the subclass inherits member data and/or member function implementations.</li>
<li>Interface inheritance - the subclass inherits member function signatures only. The member functions must be implemented in the subclass. No member data or function implementation are inherited from the base class.</li>
<li>Abstract inheritance - the subclass inherits both implementation and interface.</li>
</ol>
<p>Some languages provide keywords for the different kinds of inheritance be it interface inheritance, implementation or abstract. C++ does not provide explicit keywords for these different types of inheritance. C++ provides these different types of inheritance with particular idioms which we will cover later in the course.</p>
<p>Objects may also inherit from more than one base class. This is called multiple inheritance.</p>
<h4>Hierarchy</h4>
<p>Continuing in the quest to reduce complexity, we rank or order our set of abstractions into inheritance hierarchies. Identifying and understanding such hierarchies helps us to get a better grasp on our problem. In early days of OO development it was common to have deep hierarchies (e.g., classA subclasses classB which subclasses class C which subclasses class D) with no multiple inheritance. These deep inheritance structures became cumbersome to work with. Today, you will more often find flatter hierarchies and more multiple inheritance (e.g., classA subclasses classB and classC, and classD). Today interface inheritance is also used more than it used to be as it provides more flexibility.</p>
<h4>ISA and HASA</h4>
<p>Note that both these terms can, optionally, be spelled with a hyphen. ISA and IS-A are both acceptable, as are HASA and HAS-A.</p>
<p>Two of the most important hierarchies are the <span class="keyterm">ISA</span> (pronounced "is a" and meaning is a) and the <span class="keyterm">HASA</span> (pronunciation follows naturally). The former is traditional inheritance and is usually implemented through a public inheritance structure; the latter expresses composition or aggregation.</p>
<p>The ISA hierarchy should only be used when the derived class is <span class="italics">a-kind-of</span> the base class—that is, when the derived class extends the functionality of the base class or is a specialization of the base class. We can't derive <span class="italics">wheels</span> from <span class="italics">oranges </span>(or something that sounds like oranges), for example, simply because both are round. Further, the ISA relationship is one that exists solely between related classes.</p>
<p>The HAS-A relationship is one of aggregation or composition and suggests containment. We recognize three different forms of such a relationship. When we're working with <span class="italics">classes</span>, we have one class <span class="italics">defined</span> within a containing class. Recall the basic linked list data structure in which we have a collection of nodes, connected one to the next through pointers. One approach for implementing such a list is to define a class <span class="italics">Node</span> within the <span class="italics">List</span> class. When we use such a technique, we take advantage of the strengths of the object approach in the design of the contained class and we don't pollute the namespace. Often times, also, the properties or functionality of the contained class aren't relevant at a broader scope.</p>
<p>We can also work with a <span class="italics">class</span> and an <span class="italics">object</span>. Now, we define the class <span class="italics">Node</span> outside of the class <span class="italics">List</span> then use an instance of <span class="italics">Node</span> within <span class="italics">List</span>. In such a case, definition outside the class permits instances of the class to be used in other portions of the program.</p>
<p>Finally, if we are working with <span class="italics">objects,</span> we can have one object referring to a second. In such a case, the second object is used by the first, but is not intrinsically a part.</p>
<p>When we are working with the HAS-A relationship, we must also be aware of and concerned with the notion of ownership. With such ownership comes the responsibility of managing the memory associated with the owned object. In the first two cases above, we have a definite sense of ownership.</p>
<p>Two supporting types of relationship are CREATES-A and USES-A. The former type object acts in a server or producer role, while the latter complements the relationship in the consumer or client role. An X window manager acts as a window server to a client. Hence, the window manager is a CREATES-A type object and the client a USES-A type object.</p>
<h4>Typing</h4>
<p>Defining a class permits us to extend the language by adding a new data type. When we write a new C++ class, we have just added a new type to our program. The notion of <span class="italics">typing</span> derives from the formal theories of abstract data types. Simply put, the <span class="keyterm">type </span>of a object gives a precise characterization of its behavioral properties. We use the words "type" and "class" interchangeably. Typing is thus an enforcement of the class of an object. That is, objects of different types may not be interchanged, or they may be interchanged only in restricted ways. It's also the case that some objects of different types may be converted to another type.</p>
<p>We have three different kinds of typing: <span class="italics">strong</span>, <span class="italics">weak,</span> and <span class="italics">none. </span>With <span class="keyterm">strong typing</span>, type conformance is strictly enforced. Operations cannot be called upon an object unless the exact signature of the operation is defined by the object's class or superclass. A violation of the type is detected at compile time. With no type enforcement, an object of any class can send a message to an object of any other class. Type violations may not be known until runtime (with potentially disastrous consequences, I might add). On the other hand, <span class="keyterm">weak typing</span> is a mix of strong and no typing. C and C++ fall into this category. C++ has a tendency towards stronger typing and C towards the weaker. With weak typing, it's possible to ignore or suppress type information.</p>
<p>The words "typing" and "binding" are often used interchangeably, and often with qualifiers such as <span class="italics">static, dynamic, </span>or<span class="italics"> strong</span>. Let's look at what these mean. <span class="italics">Static</span> <span class="italics">typing</span> and <span class="italics">strong typing</span> are different concepts. <span class="italics">Strong</span> <span class="italics">typing</span> refers to type consistency, whereas <span class="keyterm">static typing</span> refers to the time that variable names are bound to the types. Static typing, also known as <span class="keyterm">static</span> or <span class="keyterm">early binding</span>, simply says that the types of the variables and expressions are fixed at compile time. In contrast, <span class="keyterm">dynamic typing</span>—also called <span class="keyterm">dynamic</span> or <span class="keyterm">late binding</span>—states that the types of the variables and expressions are not known until runtime. Thus, a language may be both statically/dynamically typed and strongly typed.</p>
<p>The semantics of dynamic binding yields the concept of runtime <span class="keyterm">polymorphism</span>. Once again, this concept is taken from type theory. It simply means that a single name may denote objects of many different classes related by some common superclass. Polymorphism occurs when the concepts of inheritance and dynamic binding interact. Polymorphism is one of the most powerful features of object-oriented languages. We'll discuss the advantages and disadvantages of using polymorphism in much greater detail in a later lesson.</p>
<h4>Concurrency</h4>
<p><span class="keyterm">Concurrency</span> is related to an ability to handle many different events simultaneously. Systems supporting concurrency may have many threads of control; some may be transitory and others may last the lifetime of the system execution. We distinguish between heavyweight processes, which are typically managed by the operating system, and lightweight processes or threads, which usually co-exist with other processes and share a common address space.</p>
<p>Concurrency focuses on process abstraction and synchronization. In the object-centered designs, we are concerned with collections of co-operating objects. Some of these objects may be active—that is, centers of independent activity—while others may be inactive. Concurrency is the property of objects that models parallel operations through an implementation based upon time-sharing a single processor.</p>
<h4>Persistence</h4>
<p>The final property of the object model that we consider is <span class="keyterm">persistence</span>. A software object takes up space; it exists for a finite period of time. Persistence, then, is a property of an object that describes its existence in time. Such an existence may take on any of the following values:</p>
<ul>
<li>The lifetime of an object may be transient, such as a variable in an expression evaluation.</li>
<li>Local variables persist while execution is in scope and then vanish when the scope is exited.</li>
<li>Certain variables may have a lifetime for which the extent is different from their scope. These, for example, may be global variables.</li>
<li>Other variables persist between executions of a program, between versions of a program, or beyond the life of the program.</li>
</ul>
<p>Variables in the first three categories are found in what we typically view as traditional programs. Those in the latter categories are found in the domain of database technology. Persistence, however, is concerned with more than just data lifetime. The state of the object must be considered as well. Values must be consistent, particularly in situations such as physically or temporally distributed systems or simulations. The class or type of an object must be considered in database situations. Every program must interpret the data in the same way.</p>
<h4>The Class Diagram</h4>
<p>The UML notation for expressing the structural relationships between classes is rich without being overly complex. The class diagram presents the various kinds of objects in the system and captures the relationships, called <span class="italics">associations</span>, among them. As illustrated in Figure 2.2, below, the notation for a class is a rectangle. Illustrated is a simple version with just name. Such a representation is often sufficient for the exploratory phases of modeling when our primary concern is the structural relationships between or among classes rather than with their attributes and operations.</p>
<p class="title"><span class="bold">Figure 2.2—Class</span></p>
<p><img src="./Lesson4_files/preview(2)" alt="Class" width="95" height="64" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384317" data-api-returntype="File" style="max-width: 945px;"></p>
<p>If more detail needed, the rectangle is subdivided into three areas as shown in Figure 2.3, below.</p>
<p><img src="./Lesson4_files/preview(3)" alt="Object Details" width="81" height="62" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384303" data-api-returntype="File" style="max-width: 945px;"></p>
<ul>
<li>Top area gives the <em>name</em> of the class or object.</li>
<li>Middle section identifies all of the <em>properties</em> of the object. These will generally be declared inside the module implementation and thereby hidden from the casual user.</li>
<li>Third pane identifies the <em>operations</em> that the class or object is intended to perform.</li>
</ul>
<p>These establish and implement the external behavior of the object. They provide the public interface to the object.</p>
<h4>Object Name</h4>
<p><em>Object Name</em> (or <em>Class Name</em>) is the identifier for the class. A common naming convention suggests that classes begin with an upper-case letter and subsequent words in the name also start with a capital letter—for example, <em>MyClass</em>. We do this to distinguish class names from variable names, which typically begin with a lower-case letter. The name of the class should be chosen so as to describe, in simple terms, what real world entity the class implements.</p>
<h4>Object Properties</h4>
<p>The <span class="keyterm">properties</span> of an object provide a mechanism to capture the structural features of that object. The property may be further elaborated as <span class="italics">attributes, associations</span> or <span class="italics">operations</span>.</p>
<h5>Attributes</h5>
<p><span class="keyterm">Attributes</span> describe a particular characteristic of a property such as the address of an output port. The syntax is given as</p>
<p>visibility name:type = optional default value<br><br> The <span class="italics">visibility</span> qualifier indicates who has access to (can read or change) the attribute. Three levels of visibility are specified:</p>
<ul>
<li>
<span class="keyterm">Public</span>—( + ) <br> The attribute is visible and can be accessed or modified by all objects in the system including the containing class.</li>
<li>
<span class="keyterm">Protected</span>—( # )<br> The attribute <em>is</em> visible within instances of the containing class and all of its subclasses, not to any other objects</li>
<li>
<span class="keyterm">Private</span>—( - )<br> The attribute <em>is</em> only visible within instances of objects of the containing class. Private visibility is how we enforce encapsulation and information hiding; it is virtually always the preferred visibility for attributes for this reason.</li>
</ul>
<p><span class="keyterm">Name</span> is the identifier for the attribute. A common naming convention suggests that attributes begin with a lower-case letter and subsequent words start with a capital letter. For example, <em>firstName.</em> <span class="keyterm">Type</span> is the type of the attribute which can be either a user defined class or an intrinsic type.</p>
<h5>Associations</h5>
<p><span class="keyterm">Associations</span> capture how the object relates to other objects within the system. A property can also be quantified by a <em>multiplicity</em> attribute, thereby identifying how many objects may fill the property. For example, the wheel on an automobile has a <em>multiplicity</em> of 4.</p>
<h5>Operations</h5>
<p>The notational elements for the visibility of <span class="keyterm">operations</span> are similar to attributes. Typically, we designate operations to be public because most form the public interface of the class. On some occasions, we do want them to be protected or private. The syntax for specifying operations is</p>
<p><code>visibility name(parameter list): return type</code></p>
<p>The naming of operations follows the same convention as the naming of attributes. The first word begins with a lower-case letter and subsequent words begin with an uppercase letter.</p>
<p>The parameter list is a comma-separated list of parameter expressions. The parameter naming conventions are same as for attributes. The syntax for a parameter in the list is</p>
<p><code>direction name:type = optional default value</code></p>
<p>Direction is one of <em>in, out, or inout.</em></p>
<ul>
<li>
<span class="keyterm">in</span>, which is the default value, means that the operation uses the value of the parameter, but, does not change it.</li>
<li>
<span class="keyterm">out</span>, indicates that the parameter is being sent to the operation for the sole purpose of being changed.</li>
<li>
<span class="keyterm">inout</span>, the input value is used and will potentially be changed by the operation.</li>
</ul>
<p>Several common operation types are needed in most classes. These include the following:</p>
<ul>
<li>
<span class="keyterm">Constructors</span>—operation(s) required to initialize an object of the class. Some languages have special naming requirements for these operations.</li>
<li>
<span class="keyterm">Destructors</span>—operations executed when an instance of the class goes out of existence. Often these are used to return system resources that were obtained when the object was created or during its subsequent life cycle. Some languages have special naming conventions for these, while others don't require them at all.</li>
<li>
<span class="keyterm">Accessors</span> (queries, "getting" operations)—operations that allow getting the current value of an attribute of the object. By convention, the names of these often start with "get" followed by the name of the attribute, or "is" followed by the attribute name in the case of Boolean attributes.</li>
<li>
<span class="keyterm">Mutators</span> (modifiers, "setting" operations)—operations that alter the values of attributes. By convention, the names of these start with "set", followed by the name of the attribute.</li>
<li>Operations directly mapped to the behavioral responsibilities of the class.</li>
<li>Helper operations that support meeting the behavioral responsibilities. These typically have a visibility of "protected" if we want subclasses to have access to them or "private" if we wish to hid them.</li>
</ul>
<p>We can usually assume that there will be public accessors and mutators for attributes that need to be available to other objects, so to save space they are often not shown in models. The same is often true of constructors and destructors. These leave operations that directly or indirectly support meeting the responsibilities of the class. These are the most important operations to model because they specify how the classes in the system fulfill their responsibilities.</p>
<p>There are no hard and fast rules for naming these kinds of members, but there is a widely-used convention that operations are named with verbs or verb phrases. Whenever the method performs some action on another object, it is common to include the class name of that object in the verb phrase forming the method name. For example, an operation called <em>renameFiles</em> in a Directory class object would be understood to change the names of the File class objects contained in the Directory.</p>
<h4>Class Diagrams—Class Relationships</h4>
<p>Now that we have learned the notation and syntax for modeling classes themselves, the next aspect of UML structural class modeling to explore is how to express the relationships between or among the classes.</p>
<p>There are some common relationships between classes; the UML has notational devices for each. In the UML, a relationship is a connection of some kind between two or more classes. These relationships fall into three broad categories:</p>
<ul>
<li>Generalization—a class is related to another class by means of generalization or specialization, as a superclass or subclass. Such a relationship is also referred to as parent-child or inheritance.</li>
<li>Association—a class has a structural relationship to another class.Such a relationship is also denoted containment or aggregation.</li>
<li>Dependency—a class uses another class.</li>
</ul>
<h4>Generalization or Inheritance</h4>
<p>Generalization, specialization, or inheritance are terms that we find used interchangeably to express the same basic concept. We are simply viewing the relationship from several different perspectives.</p>
<p>When describing (or using such a relationship in a design) we are merely saying that one class has all of the behavior, properties, and attributes of another class but, may have slightly modified or added to them. A sports car is a <em>specialization</em> of the general concept of a car. The car is a <em>generalization</em> of a sports car. The SportsCar class is a <em>child</em> of the Car class. TheCar class is a <em>parent</em> of the SportsCar class. Said yet another way (gees enough already, I get the point), the sports car <em>inherits</em> (has) all of the general car characteristics but is much cooler in many ways.</p>
<p>We express <em>generalization (specialization)</em>or <em>inheritance</em> using a solid line terminating in a hollow arrow. Figure 2.4, below, presents a portion of an external world communications interface from a computer.</p>
<p class="title"><span class="bold">Figure 2.4—External-world Communications Interface from a Computer</span></p>
<p><img src="./Lesson4_files/preview(4)" alt="External-world Communication Interface from a Computer" width="256" height="245" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384251" data-api-returntype="File" style="max-width: 945px;"></p>
<p>Therein we represent the relationship between the parent—<em>Driver</em> and two children —<em>Serial</em> and <em>Parallel</em>. We say that Serial or Parallel are <em>a kind of</em> (AKO) Driver or that Serial <em>is a</em>(IS-A) Driver. Observe that the arrow is directed from the child to the parent.</p>
<p>The diagram captures the requirement, through the parent interface, that each of the different types of interface (Serial or Parallel) must support a common subset of capabilities.</p>
<ul>
<li>There must be a port number associated with each interface</li>
<li>The driver must provide the address to an I/O buffer</li>
<li>It must manage a status flag</li>
<li>It must implement the <em>read()</em> and<em> write()</em> functions to execute the transfer</li>
</ul>
<p>The "+" appearing in the diagram indicates that each of the corresponding elements is publicly visible.</p>
<h4>Association or Containment</h4>
<p>The inheritance relationship is necessarily hierarchical. There are times, however, when such a relationship does not adequately express the interaction between classes. Under such circumstances, rather than hierarchical, an egalitarian relationship between classes and instances of classes may be more appropriate. There are at least three variations on such a relationship; these are <em>association, composition,</em> and<em> aggregation</em>.</p>
<p>Let's examine the <em>association</em> first. An association is the weakest of the three. Visiting the business world for a change, a typical example of an association is the <em>works for </em>relation we find between an employee and a company. Clearly this is not a hierarchical relation (sure Clyde may be your boss, but, most of the time, you are not Clyde's child). Neither is it a containment type of relation.</p>
<p>We express the association relationship by connecting the associated classes by a solid line as shown in Figure 2.5, below.</p>
<p class="title"><span class="bold">Figure 2.5—Association</span></p>
<p><img src="./Lesson4_files/preview(5)" alt="association" width="355" height="77" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384308" data-api-returntype="File" style="max-width: 945px;"></p>
<p><span class="keyterm">Multiplicity</span> (sometimes called <span class="keyterm">cardinality</span>) represents information about how many objects participate in the association. A multiplicity at one end of the association denotes that for each object at the other end of the association, there must be the number of objects specified in the multiplicity expression. The multiplicity expression may be a specific number or range of numbers. The standard expressions are: 1, * (many), 0..1 (zero or one), 0..* (zero, 1, or many), or m..n ("m" to "n", as in 3..5). In the figure, a Person may be an employee of many Companies, while a Company has one to many Persons as employees.<br> Observe how we annotate the association in the diagram.</p>
<p><span class="keyterm">Containment</span> conveys the idea that one object is made up of several others. The relationship implements a whole-part relationship. Under the UML, we can express two different forms of containment:</p>
<ul>
<li>aggregation; and</li>
<li>composition.</li>
</ul>
<h4>Aggregation</h4>
<p><span class="keyterm">Aggregation</span> expresses a <em>whole-part relationship</em> in which one object or module contains another module. The key characteristic of an aggregation is that one or more objects are parts of a whole. A more complex function is decomposed into number of simpler functions or modules.</p>
<p>The owned module(s) may be <em>shared</em> with other modules outside of the aggregation. Under such conditions, rules must be established to ensure proper management of the shared module.</p>
<p>Figure 2.6, below, illustrates a design in which a graphics display is implemented as an aggregate of <span class="italics">n</span> windows. Certainly windows can exist outside of the display.</p>
<p class="title"><span class="bold">Figure 2.6—Aggregate</span></p>
<p><img src="./Lesson4_files/preview(6)" alt="aggregate" width="344" height="110" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384269" data-api-returntype="File" style="max-width: 945px;"></p>
<p>The UML diagram for the aggregation relationship presents both the whole and its parts connected via a solid line that originates from an open diamond on the end associated with the whole and terminates on the end associated with the part.</p>
<h4>Composition</h4>
<p>The <span class="keyterm">composition</span> relationship is similar to aggregation. However, the notion of ownership of the parts by the whole is much stronger. Elements of the composition cannot be part of another object, that is, they cannot exist outside of the whole object. The idea is loosely analogous to local variables in a function. Once we leave the scope of the function, the local variables disappear.</p>
<p>Consider a schedule. It is made up of a number of intervals. Without the schedule, the intervals have no meaning.</p>
<p>We express such a relationship as shown in Figure 2.7, below.</p>
<p class="title"><span class="bold">Figure 2.7—Composition</span></p>
<p><img src="./Lesson4_files/preview(7)" alt="composition" width="342" height="101" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384288" data-api-returntype="File" style="max-width: 945px;"></p>
<p>The schedule is composed of 1 to <span class="italics">n</span> intervals. Observe that the diagram is similar to that for the aggregation except that the connecting line now originates from a solid rather than open diamond. We annotate the relationship as a 1 to <span class="italics">n</span> composition.</p>
<h4>Dependency</h4>
<p>As the term suggests, <span class="keyterm">dependency</span> means that one class or object depends on the behavior of another object. This implies that if the public interface or behavior of the class depended upon changes, the dependent class behavior may change, as well. While a goal of good object centered design is to minimize dependence between classes, it can never be eliminated in practice; otherwise we couldn't have any collaboration between objects at all.</p>
<p>The best practice is to ensure that you design a persistent public interface for each class that is as simple as possible, using standard naming conventions, with the most general return types. Such an approach allows you to add to the interface later as new requirements present themselves and to change the underlying implementation without changing the interface. You never want to get into a situation where substantial development has taken place and you are forced to make major changes to the public interface of a class, thus requiring many changes to dependent classes.</p>
<p>Dependency is modeled in the UML using a dashed directed line from the dependent class to the class depended on. When dependency represents just the use of a class as an attribute, it is seldom modeled. An example is String class attributes <em>firstName</em> and <em>lastName</em> in a <em>Person</em> class.</p>
<p>However, when a substantial part of the behavior of some class is delegated to another class, the dependency relationship should be modeled. For example, back in the business world, suppose we had an <em>Employee</em> class that has a <em>calculatePay</em> operation. Further, let the employee's pay be determined not only by the hours worked, but also on one of several different compensation plans, represented by a <em>CompensationPlan</em> object, with a <em>calculateCompensation</em> operation. Such a design represents a substantial delegation of responsibility from Employee to CompensationPlan, and should be modeled as a dependency relationship as we see in Figure 2.8, below.</p>
<p class="title"><span class="bold">Figure 2.8—Dependency</span></p>
<p><img src="./Lesson4_files/preview(8)" alt="dependency" width="304" height="75" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384282" data-api-returntype="File" style="max-width: 945px;"></p>
<h4>Interface</h4>
<p>An interface is an inheritance relationship. With an interface only the signatures of the member functions are inheritied. Member function implementation and member data are not part of the interface class, and thus not inheritied. We express an interface in a manner similar to that which we use for inheritance. We use a dashed line terminating in hollow arrow and tag the interface with <em>&lt;&lt;interface&gt;&gt;</em>. <br> In Figure 2.9, below, the interface <em>stack</em> gives the underlying array public appearance of a stack.</p>
<p class="title"><span class="bold">Figure 2.9—Interface</span></p>
<p><img src="./Lesson4_files/preview(9)" alt="interface" width="269" height="79" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/files/44384286" data-api-returntype="File" style="max-width: 945px;"></p>
<p>The operations, <em>push() and pop(),</em>perform the necessary steps to transform access to the array as necessary.</p>
<h3>Summary</h3>
<p>In this lesson, we have learned several ways in which the C++ language has extended C, including a new library of <code>iostream</code> functions to get data into and out of our programs.</p>
<h3>Practice&nbsp;Questions</h3>
<p>Test your understanding of the concepts presented in this lesson by working through the following practice questions, then check your answers with <a class="" title="Answers to Practice Questions for Lesson 4" href="https://canvas.uw.edu/courses/1177926/pages/answers-to-practice-questions-for-lesson-4" data-api-endpoint="https://canvas.uw.edu/api/v1/courses/1177926/pages/answers-to-practice-questions-for-lesson-4" data-api-returntype="Page">Answers to Practice Questions for Lesson 4</a>.</p>
<ol>
<li>What is UML?</li>
<li>What are the main elements of a class diagram?</li>
<li>What are some of the main relationships that can be expressed between classes in a class diagram?</li>
<li>What are CRC cards and what does the acronym stand for?</li>
</ol>
</div>
  
</div>
<div style=""><div class="module-sequence-padding"></div>
<div class="module-sequence-footer" role="navigation" aria-label="Module Navigation">
  <div class="module-sequence-footer-content">
    
      <a href="https://canvas.uw.edu/courses/1177926/modules/items/7889527" role="button" class="Button module-sequence-footer-button--previous" data-tooltip="right" data-html-tooltip-title="&lt;i class=&#39;icon-document&#39;&gt;&lt;/i&gt; Lesson 4 Overview and Materials" aria-describedby="msf0-previous-desc">
        <i class="icon-mini-arrow-left"></i>Previous
        <span id="msf0-previous-desc" class="hidden" hidden="">Previous: Lesson 4 Overview and Materials</span>
      </a>
    

    
      <span class="module-sequence-footer-button--next" data-tooltip="left" data-html-tooltip-title="&lt;i class=&#39;icon-assignment&#39;&gt;&lt;/i&gt; Assignment 4">
        <a href="https://canvas.uw.edu/courses/1177926/modules/items/7889529" role="button" class="Button" aria-describedby="msf0-next-desc">
          Next<i class="icon-mini-arrow-right"></i>
          <span id="msf0-next-desc" class="hidden" hidden="">Next: Assignment 4</span>
        </a>
      </span>
    
  </div>
</div>
</div></div>

          </div>
        </div>
        <div id="right-side-wrapper" class="ic-app-main-content__secondary">
          <aside id="right-side" role="complementary">
            
          </aside>
        </div>
      </div>
    </div>
  </div>



    <div style="display:none;"><!-- Everything inside of this should always stay hidden -->
        <div id="page_view_id">f94d0a36-0411-4a11-ab77-4370a72bfd22</div>
    </div>
    
<div id="cant_record_dialog" style="display: none;">
  <div>
    In order to create video or audio recordings your computer needs to be 
    webcam-enabled.  If you don't have a webcam on your computer, you can still
    record audio-only messages by first installing the Google Video Chat
    plugin.
  </div>
  <div style="text-align: center; font-size: 1.5em; margin: 10px;">
    <a href="http://www.google.com/chat/video" target="_blank" rel="noopener" class="btn">Install the Video Plugin</a>
  </div>
  <div class="links" style="text-align: right; font-size: 0.8em; display: none;">
    <a href="https://canvas.uw.edu/courses/1177926/pages/lesson-4?module_item_id=7889528#" class="cant_record_link">Don't have a webcam?</a>
  </div>
</div>

  <div id="aria_alerts" class="hide-text affix" role="alert" aria-live="assertive"></div>
  <div id="StudentTray__Container"></div>
  <script>
  INST = {"environment":"production","allowMediaComments":true,"kalturaSettings":{"domain":"nv.instructuremedia.com","resource_domain":"nv.instructuremedia.com","rtmp_domain":"fms-prod.instructuremedia.com","partner_id":"9","subpartner_id":"0","player_ui_conf":"0","kcw_ui_conf":"0","upload_ui_conf":"0","max_file_size_bytes":534773760,"do_analytics":false,"hide_rte_button":false,"js_uploader":true},"googleAnalyticsAccount":"UA-9138420-1","disableScribdPreviews":true,"logPageViews":true,"maxVisibleEditorButtons":3,"editorButtons":[{"name":"","id":21130,"url":"https://uw.hosted.panopto.com/Panopto/Pages/Sessions/embeddedupload.aspx","icon_url":"https://uw.hosted.panopto.com/Panopto/images/panopto_logo_globe.png","canvas_icon_class":null,"width":900,"height":700},{"name":"Modalis","id":52765,"url":"https://uw.modalis.io/lti","icon_url":"https://uw.modalis.io/assets/richicon.png","canvas_icon_class":null,"width":800,"height":600}]};
  ENV = {"ASSET_HOST":"https://du11hjcvx0uqb.cloudfront.net","active_brand_config_json_url":"https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/2b2842738c86c4f2032e430bd0445cfc/variables-750d72b9d3e5d522f965bf904110c132.json","url_to_what_gets_loaded_inside_the_tinymce_editor_css":["https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/2b2842738c86c4f2032e430bd0445cfc/variables-750d72b9d3e5d522f965bf904110c132.css","https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/new_styles_normal_contrast/bundles/what_gets_loaded_inside_the_tinymce_editor-bb4121d737.css"],"url_for_high_contrast_tinymce_editor_css":["https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/default/variables-high_contrast-750d72b9d3e5d522f965bf904110c132.css","https://du11hjcvx0uqb.cloudfront.net/dist/brandable_css/new_styles_high_contrast/bundles/what_gets_loaded_inside_the_tinymce_editor-b61a4bdaa8.css"],"current_user_id":"3757111","current_user":{"id":"3757111","display_name":"Clayton Wong","avatar_image_url":"https://canvas.uw.edu/images/thumbnails/46487823/mSs2TjTESYscSzrackhgoJvAT79xbNchamHPrSec","html_url":"https://canvas.uw.edu/about/3757111"},"current_user_roles":["user","student"],"current_user_disabled_inbox":false,"files_domain":"cluster10-files.instructure.com","DOMAIN_ROOT_ACCOUNT_ID":100000000083919,"k12":false,"use_responsive_layout":false,"help_link_name":"Help","help_link_icon":"help","use_high_contrast":false,"SETTINGS":{"open_registration":false,"eportfolios_enabled":true,"collapse_global_nav":true,"show_feedback_link":true,"enable_profiles":true},"page_view_update_url":"/page_views/f94d0a36-0411-4a11-ab77-4370a72bfd22?page_view_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpIjoiZjk0ZDBhMzYtMDQxMS00YTExLWFiNzctNDM3MGE3MmJmZDIyIiwidSI6MTAwMDAwMDAzNzU3MTExLCJjIjoiMjAxOC0wMi0wMVQxNzo1NjoyMi4zNloifQ.hgfJyJtWF7f-8gGtYcaa57BWf9cjB9THwT7es1t4skg","context_asset_string":"course_1177926","ping_url":"https://canvas.uw.edu/api/v1/courses/1177926/ping","TIMEZONE":"America/Los_Angeles","CONTEXT_TIMEZONE":"America/Los_Angeles","GRAPHQL_ENABLED":true,"LOCALE":"en","BIGEASY_LOCALE":"en_US","FULLCALENDAR_LOCALE":"en","MOMENT_LOCALE":"en","WIKI_RIGHTS":{"read":true},"PAGE_RIGHTS":{"read":true},"DEFAULT_EDITING_ROLES":"teachers","WIKI_PAGES_PATH":"/courses/1177926/pages","WIKI_PAGE":{"title":"Lesson 4","created_at":"2017-10-18T21:04:15Z","url":"lesson-4","editing_roles":"teachers","page_id":"2573095","published":true,"hide_from_students":false,"front_page":false,"html_url":"https://canvas.uw.edu/courses/1177926/pages/lesson-4","updated_at":"2017-10-18T21:04:15Z","locked_for_user":false,"body":"\u003cdiv id=\"level2\"\u003e\r\n\u003ch1\u003e\n\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384337/preview\" alt=\"L04.png\" width=\"50\" height=\"50\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384337\" data-api-returntype=\"File\"\u003e A Tour of C++ - Object concepts - UML Class Diagrams\u003c/h1\u003e\r\n\u003ch3\u003eDesign, Development, and Test\u003c/h3\u003e\r\n\u003ch4\u003eThinking in Models\u003c/h4\u003e\r\n\u003cp\u003eSoftware systems are becoming increasingly complicated and difficult to develop. Today even small systems tend to exhibit much greater capabilities and increasing numbers of features. Thus, we are continually striving to devise ways to attack complexity (it seems to be winning sometimes). One such method is to develop and use \u003cspan class=\"keyterm\"\u003emodels \u003c/span\u003eto try to abstract away the inessential details and focus on what's important. Models are simplifications of a problem—an abstract representation of a real-world entity. Objects, too, are an abstraction, a model. As we learned, they encapsulate data and the functions that operate on the data.\u003c/p\u003e\r\n\u003cp\u003eAt this point, it's a fair question to ask what makes a good model. First, it must be simple. It must be accurate. It must support abstraction and refinement. Finally, it must be extensible.\u003c/p\u003e\r\n\u003ch3\u003eObjects and the Object Model\u003c/h3\u003e\r\n\u003cp\u003eWe'll begin our study of objects and the object model by examining the process of solving problems and thinking about some of the things that are important . . . hold on here, it's important tell a little bit more about what an object is.\u003c/p\u003e\r\n\u003cp\u003eFair enough. Certainly one of the first questions that people new to object centered design ask is: \"What is an object?\" So, let's see.\u003c/p\u003e\r\n\u003cp\u003eAn object is any thing—either tangible or conceptual—that is a part of the problem domain of the software you are developing. Objects have three fundamental characteristics: \u003cspan class=\"italics\"\u003eidentity\u003c/span\u003e, \u003cspan class=\"italics\"\u003estate\u003c/span\u003e, and \u003cspan class=\"italics\"\u003ebehavior\u003c/span\u003e. A significant part of object oriented analysis is the identification of the objects in the problem domain. So, how do you know when something in your problem domain is an object? A good place to start is in the requirements document (we'll learn how to write this in a future lesson—it's basically a description of what the customer wants). As you read the requirements, look for nouns: the people, places, things, and concepts. Each is a potential object and each will have identity, state, and behavior.\u003c/p\u003e\r\n\u003ch4\u003eObject Identity\u003c/h4\u003e\r\n\u003cp\u003eIdentity is what distinguishes an object from all other objects in a software system. This may mean that it has a unique name, or that it has some other way of being uniquely identified within a program (such as a numeric identifier), or a unique position within some container of objects.\u003c/p\u003e\r\n\u003ch4\u003eObject State\u003c/h4\u003e\r\n\u003cp\u003eObjects have attributes. For example, an apple is red, green, yellow, or some mixture of these three colors. Apples also have shape, size, and weight attributes. The current value of all these attributes for a particular apple is called its state. In the object world, an object always knows its own state, and it may change that state in response to the occurrence of events or to messages it gets from other objects.\u003c/p\u003e\r\n\u003ch4\u003eObject Behavior\u003c/h4\u003e\r\n\u003cp\u003eObjects exhibit behavior by responding to events or to messages from other objects. In C++ these messages take the form of a function call. These messages may be queries about an object's current state, requests for it to change its state, or requests for the object to perform some service.\u003c/p\u003e\r\n\u003cp\u003eTo see how these concepts might apply, let's propose that we have a display that is showing a variety of different geometric shapes. Let's make several of them rectangles. When we want to move a Rectangle class object from one place to another, we first have to identify which Rectangle we want to move. We then send it the \u003cspan class=\"italics\"\u003emove\u003c/span\u003e message with some data that tell it where we want it to move on the screen. This is a pretty complex piece of behavior, and to achieve it, the object will execute three other, simpler pieces of behavior: \u003cspan class=\"italics\"\u003eerase, set the new position\u003c/span\u003e, and \u003cspan class=\"italics\"\u003edraw\u003c/span\u003e. Another way of looking at this process is as just a change in the state of the Rectangle; erasing makes it invisible, moving it changes its position, and drawing makes it visible. We will learn much more about the interrelationship of \u003cspan class=\"italics\"\u003eobject state\u003c/span\u003e and behavior in later lessons.\u003c/p\u003e\r\n\u003ch3\u003eClass\u003c/h3\u003e\r\n\u003cp\u003eIn C++ objects are implemented using classes. A class is similiar to a C struct in that the class contains data members. For example, an employee class might look like:\u003c/p\u003e\r\n\u003cpre\u003eclass Employee\r\n{\r\n    std::string firstName;\r\n    std::string lastName\r\n};\u003c/pre\u003e\r\n\u003cp\u003eA class may also contain member functions that have access to the member data. Calling a member function on a class is how we send a message to a C++ object. We'll get into more details of class in later lessons.\u003c/p\u003e\r\n\u003ch3\u003eInstance\u003c/h3\u003e\r\n\u003cp\u003eIn C++ an instance is a variable of a particular class. When the variable is created it is said that it is \"instantiated\". Here we instantiate two Employee class instances:\u003c/p\u003e\r\n\u003cpre\u003eEmployee janitor;\r\nEmployee ceo;\u003c/pre\u003e\r\n\u003cp\u003ejanitor is an instance of class Employee, and ceo is another instance of class Employee. We can also call these instances objects. A C++ developer might say I've got an Employee object, or the developer might see I've got an Employee instance. Both phrases have the same meaning.\u003c/p\u003e\r\n\u003ch3\u003eObject Oriented Design and C++\u003c/h3\u003e\r\n\u003cp\u003eTo most effectively use C++ we must understand Object Oriented analysis and design. Throughout this course and the entire C++ certificate program we will study Object Oriented analysis and design hand in hand with our learning and use of C++. We will first learn object oriented concepts (such as inheritance) before we attempt to implement these concepts in C++. Object oriented analysis and design came before C++. So first we'll attempt to get a good grasp on these OO concepts. Learning C++ will then be simpler. We'll be saying Oh, that's how C++ does data hiding, or Oh, that's how C++ does inheritance.\u003c/p\u003e\r\n\u003cp\u003eThe OO analysis and OO design would be the same (or almost the same) regardless of the language we chose to implement those concepts. So in this lesson the focus is on OO concepts and design. Through the remainder of the course we will then focus on how to implement these OO concepts in C++.\u003c/p\u003e\r\n\u003cp\u003eWhat is the advantage of programming with objects versus the programming without objects? One way to answer this is with an example. In C strings are implemented as arrays of characters. To manipulate strings in C we must write code that knows many of the details of how strings are implemented. We must allocate and deallocate memory. We must ensure the string is terminated with a null character. We must recognize the difference between operating on the string, and operating on the pointer that holds the address of the string. We must make sure we follow all the rules correctly with the string to ensure there are no bugs. We must do this over and over again in C for each string we use. When you look at C code that manipulates strings the code that manipulates strings often times makes it hard to see the higher level business rules the code is implemented versus the lower level details of string manipulation\u003c/p\u003e\r\n\u003cp\u003eIn C++ we use the std::string object. The lower level details of manipulating the string are hidden from us. These details include allocating memory, copying characters, comparing them to other string and other operations. These low level details are implemented once within the string class. We can use these details over and over again without continually reimplementing them. The amount of code required for us to manipulate a std::string is much less. In C++ we program at a higher level with std::string. As a result in C++ code (when well written) it is much easier to look at the code and see what it is trying to accomplish without getting lost in the low level details of string manipulation.\u003c/p\u003e\r\n\u003ch4\u003eProblem Solving\u003c/h4\u003e\r\n\u003cp\u003eWhen we begin the design of a new product or need to incorporate several new features into an existing one, we begin with a set of requirements usually stated in English. Our goal is to map those requirements—the real world—through a series of transformations into a solution—the abstract world. We see this process reflected in Figure 1.1, below.\u003c/p\u003e\r\n\u003cp\u003eDuring the design process, we move from the concrete, real world into the abstract. At the \u003cspan class=\"italics\"\u003eApplication\u003c/span\u003e level, entities in the problem statement are abstracted into types. At the \u003cspan class=\"italics\"\u003eSolution\u003c/span\u003e level, these entities become our objects. We abstract these into classes.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 1.1—Concrete versus Abstract\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003ca title=\"Concrete versus Abstract\" href=\"https://canvas.uw.edu/courses/1177926/files/44384312/preview\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384312\" data-api-returntype=\"File\"\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384312/preview\" alt=\"concrete vs. abstract\" width=\"369\" height=\"163\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384312\" data-api-returntype=\"File\"\u003e\u003c/a\u003e\u003c/p\u003e\r\n\u003cp\u003eLet's consider a simple problem. Our mom said, \"You're such a slob, get some culture.\" Since we always listen to mom, we decide to go start a business making yogurt. When making yogurt in large batches (batch processing, of course), we need to have the proper temperature throughout the mixture. If the temperature is too low the cultures may not grow and if too hot, the wee beasties may die. Thus, we see we need to be able to measure temperature . . . an \u003cspan class=\"italics\"\u003eentity\u003c/span\u003e. Because we're growing the yogurt in a large vat, we'll need to measure the temperature at several different locations . . . ah ha, another \u003cspan class=\"italics\"\u003eentity\u003c/span\u003e. We now abstract both of these to floating point numbers, the \u003cspan class=\"italics\"\u003etypes\u003c/span\u003e. In application space, we now have our \u003cspan class=\"italics\"\u003eentities\u003c/span\u003e and our \u003cspan class=\"italics\"\u003etypes\u003c/span\u003e.\u003c/p\u003e\r\n\u003cp\u003eMeanwhile, over in the solution space, we have temperature objects and location objects which we will abstract to \u003cspan class=\"italics\"\u003eTemperature\u003c/span\u003e and \u003cspan class=\"italics\"\u003eLocation\u003c/span\u003e classes. If we were to design such a system, we'd probably create a parent class called \u003cspan class=\"italics\"\u003eYogurtTemp\u003c/span\u003e or some such thing. Such a class would have at least two data members: the temperature and the location within the vat where the temperature was measured.\u003c/p\u003e\r\n\u003cp\u003eWith this brief introduction, we begin with the question, \u003cspan class=\"italics\"\u003eCan you think in Objects?\u003c/span\u003e\u003c/p\u003e\r\n\u003ch4\u003eThinking in Objects\u003c/h4\u003e\r\n\u003cp\u003eTo start thinking in objects, let's first define some terms.\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eObject-oriented Programming\u003c/span\u003e is a method of implementation in which a program is organized as a co-operative collection of objects. Each such object represents an instance of some class. Within the program, the classes may be members of a hierarchy of classes, united via inheritance relationships. This is the approach we will use as we begin to explore the design process. Often, we'll use aggregation (collecting things together) rather that inheritance, though.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eObject-oriented Requirements\u003c/span\u003e is a method of analysis that captures the behavioral requirements of a system.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eObject-oriented Design\u003c/span\u003e is a method of design encompassing the process of object-oriented decomposition and a notation for depicting logical and physical models of system.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eWhen doing object-centered design, we will often use the \u003cspan class=\"italics\"\u003eUnified Modeling Language\u003c/span\u003e (UML) as our modeling notation and one of our tools. We'll study UML throughout this course.\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eObject-oriented Analysis\u003c/span\u003e is a method of analysis that examines the requirements of the problem from perspective of (entities) objects and classes that are found in the vocabulary of the problem domain.\u003c/p\u003e\r\n\u003cp\u003eWhen we analyze a problem, the vocabulary of the problem domain is where we look for the nouns, verbs, adjectives, and adverbs that will become our objects, actions, and object properties. We will use the CRC card (Classes, Responsibilities, Collaborators) method which is one common approach for object discovery.\u003c/p\u003e\r\n\u003ch3\u003eClass-responsibility-collaboration cards (CRC cards)\u003c/h3\u003e\r\n\u003cp\u003eClass Responsibility Collaboration (CRC) cards are a brainstorming tool used in the design of object-oriented software. They were proposed by Ward Cunningham and Kent Beck. [1] They are typically used when first determining which classes are needed and how they will interact.\u003c/p\u003e\r\n\u003cp\u003eCRC cards are usually created from index cards on which are written:\u003c/p\u003e\r\n\u003col\u003e\r\n\u003cli\u003eThe class name\u003c/li\u003e\r\n\u003cli\u003eIts Super and Sub classes (if applicable)\u003c/li\u003e\r\n\u003cli\u003eThe responsibilities of the class.\u003c/li\u003e\r\n\u003cli\u003eThe names of other classes with which the class will collaborate to fulfill its responsibilities.\u003c/li\u003e\r\n\u003cli\u003eAuthor\u003c/li\u003e\r\n\u003c/ol\u003e\r\n\u003cp\u003eUsing a small card keeps the complexity of the design at a minimum. It focuses the designer on the essentials of the class and prevents her/him from getting into its details and inner workings at a time when such detail is probably counter-productive. It also forces the designer to refrain from giving the class too many responsibilities. Because the cards are portable, they can easily be laid out on a table and re-arranged while discussing a design with other people.\u003c/p\u003e\r\n\u003cp\u003eA common method to determine what cards should be created is to read a specification for the program being designed and consider if each noun should be a class and if each verb should be a responsibility of the noun or class to which it belongs. Naturally, the existence of a noun or verb does not require a class or responsibility in the program, but it is considered a good starting point.\u003c/p\u003e\r\n\u003ch3\u003eThe Object Model\u003c/h3\u003e\r\n\u003cp\u003eIn the opening of this lesson, we've identified several of the more common programming styles, classified by how data and functions are encapsulated. We've learned that in the object-centered style, the means of encapsulation is objects. Clearly, there is no single method that is the best for every problem and every application. Each of these programming paradigms has its strengths and weaknesses. Each has its own conceptual framework. Each requires its own way of thinking about the problem. For the object-centered style, the framework is the \u003cspan class=\"italics\"\u003eobject model\u003c/span\u003e. When we move inside the object, we find the model comprises four major elements and three minor ones. The major elements include \u003cspan class=\"italics\"\u003eabstraction, encapsulation, modularity\u003c/span\u003e, and \u003cspan class=\"italics\"\u003ehierarchy\u003c/span\u003e. The minor elements consist of \u003cspan class=\"italics\"\u003etyping, concurrency,\u003c/span\u003e and \u003cspan class=\"italics\"\u003epersistence\u003c/span\u003e. We will examine each of these.\u003c/p\u003e\r\n\u003ch4\u003eAbstraction\u003c/h4\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eAbstraction\u003c/span\u003e is an effective means of dealing with complexity. When we abstract something, we focus on its outside view . . . on its outside behavior . . . how others perceive it. An abstraction identifies those essential characteristics of the object that distinguish it from all other objects. The abstraction defines crisp conceptual boundaries. A good abstraction emphasizes details that are significant and suppresses those that are not. In designing objects, we identify two main kinds of abstraction: \u003cspan class=\"italics\"\u003eentity\u003c/span\u003e and\u003cspan class=\"italics\"\u003e action\u003c/span\u003e.\u003c/p\u003e\r\n\u003cp\u003eWith \u003cspan class=\"keyterm\"\u003eentity abstraction\u003c/span\u003e, we develop objects or models that represent elements in the problem domain. Such models, usually nouns, directly parallel the vocabulary of that domain. These may represent a linked list, electronic part, display device, or file system. At this level, we make no statement about how such an object is implemented.\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eAction abstraction\u003c/span\u003e(or action objects)\u003cspan class=\"italics\"\u003e, \u003c/span\u003ebased upon the verbs in the problem domain, provides a generalized set of operations that all perform the same kind of function. Such actions may include inserting, copying, moving, sorting, or searching.\u003c/p\u003e\r\n\u003ch4\u003eEncapsulation\u003c/h4\u003e\r\n\u003cp\u003e\u003cspan class=\"italics\"\u003eEncapsulation\u003c/span\u003e is a complement to abstraction. Encapsulation is grouping data and functions that operate on that data together. In C++ objects have both data and functions that operate on that data. The data and functions are encapsulated using the C++ class. The data associated with a class is called \"member data\". Functions that operate on that data and that are associated with the class are called \"member functions\". Member is used as in \"member\" of the class.\u003c/p\u003e\r\n\u003ch4\u003eInformation Hiding\u003c/h4\u003e\r\n\u003cp\u003eIn object-centered design, we look at an object as a \"black box.\" It must have a public interface that permits the user of instances of the object to access the object. At the same time, it does not give access to the internals of the object. The internals are kept private. In other words the private data is \"hidden\". Encapsulation provides explicit barriers among abstractions; it is the process of compartmentalizing elements of an abstraction. Its structure serves to separate the constructional interface from the implementation.\u003c/p\u003e\r\n\u003cp\u003eWhen we use information hiding, we want to make certain inessential and unnecessary details inaccessible. Our motive is to reduce the number of details that we need to deal with. We want the interaction among objects to be as simple as possible, to reduce the chances of incorrect or unintended interactions or mistakes. Thus, encapsulation helps reduce the chances of system corruption. That is, a change in one area does not result in unanticipated change in another.\u003c/p\u003e\r\n\u003cp\u003eConsider, for example a bank account. We can make deposits or withdrawals or enquire about our balance, using a teller, a bank machine, or a telephone. We do not have to have knowledge about how such operations are accomplished or changed, presuming they're done correctly (although, looking at some of today's banking, we may want to pay a bit more attention).\u003c/p\u003e\r\n\u003ch4\u003ePolymorphism\u003c/h4\u003e\r\n\u003cp\u003ePolymorphism means that some code or operations or objects behave differently when responding to the same message. For example, the + (plus) operator in C++ performs different operations depending on the data type it is applied to:\u003c/p\u003e\r\n\u003cpre\u003e4 + 5       \u0026lt;-- integer=\"\" addition=\"\" 3=\"\" 14=\"\" 2=\"\" 0=\"\" --=\"\" floating=\"\" point=\"\" s1=\"\" bar=\"\" string=\"\" concatenation=\"\" pre=\"\"\u0026gt;\u003c/pre\u003e\r\n\u003cp\u003eThis type of polymorphism is called overloading.\u003c/p\u003e\r\n\u003cp\u003eTypically, when the term polymorphism is used with C++, however, it refers to using virtual methods. A virtual method is defined in a base class, but the implementation (i.e., code) is provided in the derived class. A classic example is an Drawable base class with a polymorphic method draw(). Both a Circle and Square subclass Drawable. Circle::draw draws a circle, while Square::draw() draws a square. Note we have also introduced the :: operator. :: is called the scope resolution operator and is used to determine which draw method is being referenced in the code.\u003c/p\u003e\r\n\u003ch4\u003eModularity\u003c/h4\u003e\r\n\u003cp\u003eModularity is the act of partitioning a program into individual components to reduce complexity. The modules serve as physical containers and declare the classes and objects of the logical design. Modularity describes a system that has been decomposed into a set of cohesive \u003cspan class=\"keyterm\"\u003eloosely coupled\u003c/span\u003e modules. \"Loosely coupled\" is the key phrase here. We want to localize the effect of changes. A common problem among some of my beginning students is this lament: \"But I never changed anything near there! Why did that suddenly break?\" Ahhh, they'll learn, they'll learn, as they gain more experience . . . but do they listen now?\u003c/p\u003e\r\n\u003cp\u003eWe must consider several things about modularity.\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eFirst, modules serve as elementary, indivisible units of software or hardware; this is still a consideration in object-oriented design. We try to package classes and objects to promote reuse. When we begin to design something, we must always remember to look to the next project. Ask questions like, \"How can we modify our current design to support a future feature?\" This is where the marketing and sales people really help us.\u003c/li\u003e\r\n\u003cli\u003eSecond, many compilers generate object code in segments, one for each module. Such actions may place size restrictions on the individual modules. Poor module builds can significantly affect memory access, increase cache misses, and promote thrashing.\u003c/li\u003e\r\n\u003cli\u003eThird, when modularizing a design, we should consider work assignments. Often, such assignments are made module by module. We should consider defining module boundaries so as to minimize interfaces among different parts of the organization. Such a practice simplifies the process of subcontracting some of the work as well. It also lets experienced people keep the good stuff and give the mundane—I mean, opportunities to learn!—to the new designers.\u003c/li\u003e\r\n\u003cli\u003eFourth, we should package the modules with the goal of stabilizing the module interfaces during the early part of the design. We'll talk about how we approach this shortly.\u003c/li\u003e\r\n\u003cli\u003eFinally, when modularizing a design, we need to consider security issues. Whether working for a toy company or on a sensitive government project, we need to consider what information we make available to outside vendors. By properly decomposing a system, we can more easily select which portion we want to farm out and which we need to retain control over.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003ch4\u003eInheritance\u003c/h4\u003e\r\n\u003cp\u003eAn object can inherit member functions, member data, and member function signatures (i.e., interface) from another class. A class that inherits from another class is called a subclass or derived class. A class that is inherited from is called a superclass or base class. There are 3 basic inheritance types:\u003c/p\u003e\r\n\u003col\u003e\r\n\u003cli\u003eImplementation inheritance - the subclass inherits member data and/or member function implementations.\u003c/li\u003e\r\n\u003cli\u003eInterface inheritance - the subclass inherits member function signatures only. The member functions must be implemented in the subclass. No member data or function implementation are inherited from the base class.\u003c/li\u003e\r\n\u003cli\u003eAbstract inheritance - the subclass inherits both implementation and interface.\u003c/li\u003e\r\n\u003c/ol\u003e\r\n\u003cp\u003eSome languages provide keywords for the different kinds of inheritance be it interface inheritance, implementation or abstract. C++ does not provide explicit keywords for these different types of inheritance. C++ provides these different types of inheritance with particular idioms which we will cover later in the course.\u003c/p\u003e\r\n\u003cp\u003eObjects may also inherit from more than one base class. This is called multiple inheritance.\u003c/p\u003e\r\n\u003ch4\u003eHierarchy\u003c/h4\u003e\r\n\u003cp\u003eContinuing in the quest to reduce complexity, we rank or order our set of abstractions into inheritance hierarchies. Identifying and understanding such hierarchies helps us to get a better grasp on our problem. In early days of OO development it was common to have deep hierarchies (e.g., classA subclasses classB which subclasses class C which subclasses class D) with no multiple inheritance. These deep inheritance structures became cumbersome to work with. Today, you will more often find flatter hierarchies and more multiple inheritance (e.g., classA subclasses classB and classC, and classD). Today interface inheritance is also used more than it used to be as it provides more flexibility.\u003c/p\u003e\r\n\u003ch4\u003eISA and HASA\u003c/h4\u003e\r\n\u003cp\u003eNote that both these terms can, optionally, be spelled with a hyphen. ISA and IS-A are both acceptable, as are HASA and HAS-A.\u003c/p\u003e\r\n\u003cp\u003eTwo of the most important hierarchies are the \u003cspan class=\"keyterm\"\u003eISA\u003c/span\u003e (pronounced \"is a\" and meaning is a) and the \u003cspan class=\"keyterm\"\u003eHASA\u003c/span\u003e (pronunciation follows naturally). The former is traditional inheritance and is usually implemented through a public inheritance structure; the latter expresses composition or aggregation.\u003c/p\u003e\r\n\u003cp\u003eThe ISA hierarchy should only be used when the derived class is \u003cspan class=\"italics\"\u003ea-kind-of\u003c/span\u003e the base class—that is, when the derived class extends the functionality of the base class or is a specialization of the base class. We can't derive \u003cspan class=\"italics\"\u003ewheels\u003c/span\u003e from \u003cspan class=\"italics\"\u003eoranges \u003c/span\u003e(or something that sounds like oranges), for example, simply because both are round. Further, the ISA relationship is one that exists solely between related classes.\u003c/p\u003e\r\n\u003cp\u003eThe HAS-A relationship is one of aggregation or composition and suggests containment. We recognize three different forms of such a relationship. When we're working with \u003cspan class=\"italics\"\u003eclasses\u003c/span\u003e, we have one class \u003cspan class=\"italics\"\u003edefined\u003c/span\u003e within a containing class. Recall the basic linked list data structure in which we have a collection of nodes, connected one to the next through pointers. One approach for implementing such a list is to define a class \u003cspan class=\"italics\"\u003eNode\u003c/span\u003e within the \u003cspan class=\"italics\"\u003eList\u003c/span\u003e class. When we use such a technique, we take advantage of the strengths of the object approach in the design of the contained class and we don't pollute the namespace. Often times, also, the properties or functionality of the contained class aren't relevant at a broader scope.\u003c/p\u003e\r\n\u003cp\u003eWe can also work with a \u003cspan class=\"italics\"\u003eclass\u003c/span\u003e and an \u003cspan class=\"italics\"\u003eobject\u003c/span\u003e. Now, we define the class \u003cspan class=\"italics\"\u003eNode\u003c/span\u003e outside of the class \u003cspan class=\"italics\"\u003eList\u003c/span\u003e then use an instance of \u003cspan class=\"italics\"\u003eNode\u003c/span\u003e within \u003cspan class=\"italics\"\u003eList\u003c/span\u003e. In such a case, definition outside the class permits instances of the class to be used in other portions of the program.\u003c/p\u003e\r\n\u003cp\u003eFinally, if we are working with \u003cspan class=\"italics\"\u003eobjects,\u003c/span\u003e we can have one object referring to a second. In such a case, the second object is used by the first, but is not intrinsically a part.\u003c/p\u003e\r\n\u003cp\u003eWhen we are working with the HAS-A relationship, we must also be aware of and concerned with the notion of ownership. With such ownership comes the responsibility of managing the memory associated with the owned object. In the first two cases above, we have a definite sense of ownership.\u003c/p\u003e\r\n\u003cp\u003eTwo supporting types of relationship are CREATES-A and USES-A. The former type object acts in a server or producer role, while the latter complements the relationship in the consumer or client role. An X window manager acts as a window server to a client. Hence, the window manager is a CREATES-A type object and the client a USES-A type object.\u003c/p\u003e\r\n\u003ch4\u003eTyping\u003c/h4\u003e\r\n\u003cp\u003eDefining a class permits us to extend the language by adding a new data type. When we write a new C++ class, we have just added a new type to our program. The notion of \u003cspan class=\"italics\"\u003etyping\u003c/span\u003e derives from the formal theories of abstract data types. Simply put, the \u003cspan class=\"keyterm\"\u003etype \u003c/span\u003eof a object gives a precise characterization of its behavioral properties. We use the words \"type\" and \"class\" interchangeably. Typing is thus an enforcement of the class of an object. That is, objects of different types may not be interchanged, or they may be interchanged only in restricted ways. It's also the case that some objects of different types may be converted to another type.\u003c/p\u003e\r\n\u003cp\u003eWe have three different kinds of typing: \u003cspan class=\"italics\"\u003estrong\u003c/span\u003e, \u003cspan class=\"italics\"\u003eweak,\u003c/span\u003e and \u003cspan class=\"italics\"\u003enone. \u003c/span\u003eWith \u003cspan class=\"keyterm\"\u003estrong typing\u003c/span\u003e, type conformance is strictly enforced. Operations cannot be called upon an object unless the exact signature of the operation is defined by the object's class or superclass. A violation of the type is detected at compile time. With no type enforcement, an object of any class can send a message to an object of any other class. Type violations may not be known until runtime (with potentially disastrous consequences, I might add). On the other hand, \u003cspan class=\"keyterm\"\u003eweak typing\u003c/span\u003e is a mix of strong and no typing. C and C++ fall into this category. C++ has a tendency towards stronger typing and C towards the weaker. With weak typing, it's possible to ignore or suppress type information.\u003c/p\u003e\r\n\u003cp\u003eThe words \"typing\" and \"binding\" are often used interchangeably, and often with qualifiers such as \u003cspan class=\"italics\"\u003estatic, dynamic, \u003c/span\u003eor\u003cspan class=\"italics\"\u003e strong\u003c/span\u003e. Let's look at what these mean. \u003cspan class=\"italics\"\u003eStatic\u003c/span\u003e \u003cspan class=\"italics\"\u003etyping\u003c/span\u003e and \u003cspan class=\"italics\"\u003estrong typing\u003c/span\u003e are different concepts. \u003cspan class=\"italics\"\u003eStrong\u003c/span\u003e \u003cspan class=\"italics\"\u003etyping\u003c/span\u003e refers to type consistency, whereas \u003cspan class=\"keyterm\"\u003estatic typing\u003c/span\u003e refers to the time that variable names are bound to the types. Static typing, also known as \u003cspan class=\"keyterm\"\u003estatic\u003c/span\u003e or \u003cspan class=\"keyterm\"\u003eearly binding\u003c/span\u003e, simply says that the types of the variables and expressions are fixed at compile time. In contrast, \u003cspan class=\"keyterm\"\u003edynamic typing\u003c/span\u003e—also called \u003cspan class=\"keyterm\"\u003edynamic\u003c/span\u003e or \u003cspan class=\"keyterm\"\u003elate binding\u003c/span\u003e—states that the types of the variables and expressions are not known until runtime. Thus, a language may be both statically/dynamically typed and strongly typed.\u003c/p\u003e\r\n\u003cp\u003eThe semantics of dynamic binding yields the concept of runtime \u003cspan class=\"keyterm\"\u003epolymorphism\u003c/span\u003e. Once again, this concept is taken from type theory. It simply means that a single name may denote objects of many different classes related by some common superclass. Polymorphism occurs when the concepts of inheritance and dynamic binding interact. Polymorphism is one of the most powerful features of object-oriented languages. We'll discuss the advantages and disadvantages of using polymorphism in much greater detail in a later lesson.\u003c/p\u003e\r\n\u003ch4\u003eConcurrency\u003c/h4\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eConcurrency\u003c/span\u003e is related to an ability to handle many different events simultaneously. Systems supporting concurrency may have many threads of control; some may be transitory and others may last the lifetime of the system execution. We distinguish between heavyweight processes, which are typically managed by the operating system, and lightweight processes or threads, which usually co-exist with other processes and share a common address space.\u003c/p\u003e\r\n\u003cp\u003eConcurrency focuses on process abstraction and synchronization. In the object-centered designs, we are concerned with collections of co-operating objects. Some of these objects may be active—that is, centers of independent activity—while others may be inactive. Concurrency is the property of objects that models parallel operations through an implementation based upon time-sharing a single processor.\u003c/p\u003e\r\n\u003ch4\u003ePersistence\u003c/h4\u003e\r\n\u003cp\u003eThe final property of the object model that we consider is \u003cspan class=\"keyterm\"\u003epersistence\u003c/span\u003e. A software object takes up space; it exists for a finite period of time. Persistence, then, is a property of an object that describes its existence in time. Such an existence may take on any of the following values:\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eThe lifetime of an object may be transient, such as a variable in an expression evaluation.\u003c/li\u003e\r\n\u003cli\u003eLocal variables persist while execution is in scope and then vanish when the scope is exited.\u003c/li\u003e\r\n\u003cli\u003eCertain variables may have a lifetime for which the extent is different from their scope. These, for example, may be global variables.\u003c/li\u003e\r\n\u003cli\u003eOther variables persist between executions of a program, between versions of a program, or beyond the life of the program.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eVariables in the first three categories are found in what we typically view as traditional programs. Those in the latter categories are found in the domain of database technology. Persistence, however, is concerned with more than just data lifetime. The state of the object must be considered as well. Values must be consistent, particularly in situations such as physically or temporally distributed systems or simulations. The class or type of an object must be considered in database situations. Every program must interpret the data in the same way.\u003c/p\u003e\r\n\u003ch4\u003eThe Class Diagram\u003c/h4\u003e\r\n\u003cp\u003eThe UML notation for expressing the structural relationships between classes is rich without being overly complex. The class diagram presents the various kinds of objects in the system and captures the relationships, called \u003cspan class=\"italics\"\u003eassociations\u003c/span\u003e, among them. As illustrated in Figure 2.2, below, the notation for a class is a rectangle. Illustrated is a simple version with just name. Such a representation is often sufficient for the exploratory phases of modeling when our primary concern is the structural relationships between or among classes rather than with their attributes and operations.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.2—Class\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384317/preview\" alt=\"Class\" width=\"95\" height=\"64\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384317\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eIf more detail needed, the rectangle is subdivided into three areas as shown in Figure 2.3, below.\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384303/preview\" alt=\"Object Details\" width=\"81\" height=\"62\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384303\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eTop area gives the \u003cem\u003ename\u003c/em\u003e of the class or object.\u003c/li\u003e\r\n\u003cli\u003eMiddle section identifies all of the \u003cem\u003eproperties\u003c/em\u003e of the object. These will generally be declared inside the module implementation and thereby hidden from the casual user.\u003c/li\u003e\r\n\u003cli\u003eThird pane identifies the \u003cem\u003eoperations\u003c/em\u003e that the class or object is intended to perform.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eThese establish and implement the external behavior of the object. They provide the public interface to the object.\u003c/p\u003e\r\n\u003ch4\u003eObject Name\u003c/h4\u003e\r\n\u003cp\u003e\u003cem\u003eObject Name\u003c/em\u003e (or \u003cem\u003eClass Name\u003c/em\u003e) is the identifier for the class. A common naming convention suggests that classes begin with an upper-case letter and subsequent words in the name also start with a capital letter—for example, \u003cem\u003eMyClass\u003c/em\u003e. We do this to distinguish class names from variable names, which typically begin with a lower-case letter. The name of the class should be chosen so as to describe, in simple terms, what real world entity the class implements.\u003c/p\u003e\r\n\u003ch4\u003eObject Properties\u003c/h4\u003e\r\n\u003cp\u003eThe \u003cspan class=\"keyterm\"\u003eproperties\u003c/span\u003e of an object provide a mechanism to capture the structural features of that object. The property may be further elaborated as \u003cspan class=\"italics\"\u003eattributes, associations\u003c/span\u003e or \u003cspan class=\"italics\"\u003eoperations\u003c/span\u003e.\u003c/p\u003e\r\n\u003ch5\u003eAttributes\u003c/h5\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eAttributes\u003c/span\u003e describe a particular characteristic of a property such as the address of an output port. The syntax is given as\u003c/p\u003e\r\n\u003cp\u003evisibility name:type = optional default value\u003cbr\u003e\u003cbr\u003e The \u003cspan class=\"italics\"\u003evisibility\u003c/span\u003e qualifier indicates who has access to (can read or change) the attribute. Three levels of visibility are specified:\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003ePublic\u003c/span\u003e—( + ) \u003cbr\u003e The attribute is visible and can be accessed or modified by all objects in the system including the containing class.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eProtected\u003c/span\u003e—( # )\u003cbr\u003e The attribute \u003cem\u003eis\u003c/em\u003e visible within instances of the containing class and all of its subclasses, not to any other objects\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003ePrivate\u003c/span\u003e—( - )\u003cbr\u003e The attribute \u003cem\u003eis\u003c/em\u003e only visible within instances of objects of the containing class. Private visibility is how we enforce encapsulation and information hiding; it is virtually always the preferred visibility for attributes for this reason.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eName\u003c/span\u003e is the identifier for the attribute. A common naming convention suggests that attributes begin with a lower-case letter and subsequent words start with a capital letter. For example, \u003cem\u003efirstName.\u003c/em\u003e \u003cspan class=\"keyterm\"\u003eType\u003c/span\u003e is the type of the attribute which can be either a user defined class or an intrinsic type.\u003c/p\u003e\r\n\u003ch5\u003eAssociations\u003c/h5\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eAssociations\u003c/span\u003e capture how the object relates to other objects within the system. A property can also be quantified by a \u003cem\u003emultiplicity\u003c/em\u003e attribute, thereby identifying how many objects may fill the property. For example, the wheel on an automobile has a \u003cem\u003emultiplicity\u003c/em\u003e of 4.\u003c/p\u003e\r\n\u003ch5\u003eOperations\u003c/h5\u003e\r\n\u003cp\u003eThe notational elements for the visibility of \u003cspan class=\"keyterm\"\u003eoperations\u003c/span\u003e are similar to attributes. Typically, we designate operations to be public because most form the public interface of the class. On some occasions, we do want them to be protected or private. The syntax for specifying operations is\u003c/p\u003e\r\n\u003cp\u003e\u003ccode\u003evisibility name(parameter list): return type\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003eThe naming of operations follows the same convention as the naming of attributes. The first word begins with a lower-case letter and subsequent words begin with an uppercase letter.\u003c/p\u003e\r\n\u003cp\u003eThe parameter list is a comma-separated list of parameter expressions. The parameter naming conventions are same as for attributes. The syntax for a parameter in the list is\u003c/p\u003e\r\n\u003cp\u003e\u003ccode\u003edirection name:type = optional default value\u003c/code\u003e\u003c/p\u003e\r\n\u003cp\u003eDirection is one of \u003cem\u003ein, out, or inout.\u003c/em\u003e\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003ein\u003c/span\u003e, which is the default value, means that the operation uses the value of the parameter, but, does not change it.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eout\u003c/span\u003e, indicates that the parameter is being sent to the operation for the sole purpose of being changed.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003einout\u003c/span\u003e, the input value is used and will potentially be changed by the operation.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eSeveral common operation types are needed in most classes. These include the following:\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eConstructors\u003c/span\u003e—operation(s) required to initialize an object of the class. Some languages have special naming requirements for these operations.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eDestructors\u003c/span\u003e—operations executed when an instance of the class goes out of existence. Often these are used to return system resources that were obtained when the object was created or during its subsequent life cycle. Some languages have special naming conventions for these, while others don't require them at all.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eAccessors\u003c/span\u003e (queries, \"getting\" operations)—operations that allow getting the current value of an attribute of the object. By convention, the names of these often start with \"get\" followed by the name of the attribute, or \"is\" followed by the attribute name in the case of Boolean attributes.\u003c/li\u003e\r\n\u003cli\u003e\n\u003cspan class=\"keyterm\"\u003eMutators\u003c/span\u003e (modifiers, \"setting\" operations)—operations that alter the values of attributes. By convention, the names of these start with \"set\", followed by the name of the attribute.\u003c/li\u003e\r\n\u003cli\u003eOperations directly mapped to the behavioral responsibilities of the class.\u003c/li\u003e\r\n\u003cli\u003eHelper operations that support meeting the behavioral responsibilities. These typically have a visibility of \"protected\" if we want subclasses to have access to them or \"private\" if we wish to hid them.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eWe can usually assume that there will be public accessors and mutators for attributes that need to be available to other objects, so to save space they are often not shown in models. The same is often true of constructors and destructors. These leave operations that directly or indirectly support meeting the responsibilities of the class. These are the most important operations to model because they specify how the classes in the system fulfill their responsibilities.\u003c/p\u003e\r\n\u003cp\u003eThere are no hard and fast rules for naming these kinds of members, but there is a widely-used convention that operations are named with verbs or verb phrases. Whenever the method performs some action on another object, it is common to include the class name of that object in the verb phrase forming the method name. For example, an operation called \u003cem\u003erenameFiles\u003c/em\u003e in a Directory class object would be understood to change the names of the File class objects contained in the Directory.\u003c/p\u003e\r\n\u003ch4\u003eClass Diagrams—Class Relationships\u003c/h4\u003e\r\n\u003cp\u003eNow that we have learned the notation and syntax for modeling classes themselves, the next aspect of UML structural class modeling to explore is how to express the relationships between or among the classes.\u003c/p\u003e\r\n\u003cp\u003eThere are some common relationships between classes; the UML has notational devices for each. In the UML, a relationship is a connection of some kind between two or more classes. These relationships fall into three broad categories:\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eGeneralization—a class is related to another class by means of generalization or specialization, as a superclass or subclass. Such a relationship is also referred to as parent-child or inheritance.\u003c/li\u003e\r\n\u003cli\u003eAssociation—a class has a structural relationship to another class.Such a relationship is also denoted containment or aggregation.\u003c/li\u003e\r\n\u003cli\u003eDependency—a class uses another class.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003ch4\u003eGeneralization or Inheritance\u003c/h4\u003e\r\n\u003cp\u003eGeneralization, specialization, or inheritance are terms that we find used interchangeably to express the same basic concept. We are simply viewing the relationship from several different perspectives.\u003c/p\u003e\r\n\u003cp\u003eWhen describing (or using such a relationship in a design) we are merely saying that one class has all of the behavior, properties, and attributes of another class but, may have slightly modified or added to them. A sports car is a \u003cem\u003especialization\u003c/em\u003e of the general concept of a car. The car is a \u003cem\u003egeneralization\u003c/em\u003e of a sports car. The SportsCar class is a \u003cem\u003echild\u003c/em\u003e of the Car class. TheCar class is a \u003cem\u003eparent\u003c/em\u003e of the SportsCar class. Said yet another way (gees enough already, I get the point), the sports car \u003cem\u003einherits\u003c/em\u003e (has) all of the general car characteristics but is much cooler in many ways.\u003c/p\u003e\r\n\u003cp\u003eWe express \u003cem\u003egeneralization (specialization)\u003c/em\u003eor \u003cem\u003einheritance\u003c/em\u003e using a solid line terminating in a hollow arrow. Figure 2.4, below, presents a portion of an external world communications interface from a computer.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.4—External-world Communications Interface from a Computer\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384251/preview\" alt=\"External-world Communication Interface from a Computer\" width=\"256\" height=\"245\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384251\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eTherein we represent the relationship between the parent—\u003cem\u003eDriver\u003c/em\u003e and two children —\u003cem\u003eSerial\u003c/em\u003e and \u003cem\u003eParallel\u003c/em\u003e. We say that Serial or Parallel are \u003cem\u003ea kind of\u003c/em\u003e (AKO) Driver or that Serial \u003cem\u003eis a\u003c/em\u003e(IS-A) Driver. Observe that the arrow is directed from the child to the parent.\u003c/p\u003e\r\n\u003cp\u003eThe diagram captures the requirement, through the parent interface, that each of the different types of interface (Serial or Parallel) must support a common subset of capabilities.\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eThere must be a port number associated with each interface\u003c/li\u003e\r\n\u003cli\u003eThe driver must provide the address to an I/O buffer\u003c/li\u003e\r\n\u003cli\u003eIt must manage a status flag\u003c/li\u003e\r\n\u003cli\u003eIt must implement the \u003cem\u003eread()\u003c/em\u003e and\u003cem\u003e write()\u003c/em\u003e functions to execute the transfer\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003cp\u003eThe \"+\" appearing in the diagram indicates that each of the corresponding elements is publicly visible.\u003c/p\u003e\r\n\u003ch4\u003eAssociation or Containment\u003c/h4\u003e\r\n\u003cp\u003eThe inheritance relationship is necessarily hierarchical. There are times, however, when such a relationship does not adequately express the interaction between classes. Under such circumstances, rather than hierarchical, an egalitarian relationship between classes and instances of classes may be more appropriate. There are at least three variations on such a relationship; these are \u003cem\u003eassociation, composition,\u003c/em\u003e and\u003cem\u003e aggregation\u003c/em\u003e.\u003c/p\u003e\r\n\u003cp\u003eLet's examine the \u003cem\u003eassociation\u003c/em\u003e first. An association is the weakest of the three. Visiting the business world for a change, a typical example of an association is the \u003cem\u003eworks for \u003c/em\u003erelation we find between an employee and a company. Clearly this is not a hierarchical relation (sure Clyde may be your boss, but, most of the time, you are not Clyde's child). Neither is it a containment type of relation.\u003c/p\u003e\r\n\u003cp\u003eWe express the association relationship by connecting the associated classes by a solid line as shown in Figure 2.5, below.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.5—Association\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384308/preview\" alt=\"association\" width=\"355\" height=\"77\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384308\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eMultiplicity\u003c/span\u003e (sometimes called \u003cspan class=\"keyterm\"\u003ecardinality\u003c/span\u003e) represents information about how many objects participate in the association. A multiplicity at one end of the association denotes that for each object at the other end of the association, there must be the number of objects specified in the multiplicity expression. The multiplicity expression may be a specific number or range of numbers. The standard expressions are: 1, * (many), 0..1 (zero or one), 0..* (zero, 1, or many), or m..n (\"m\" to \"n\", as in 3..5). In the figure, a Person may be an employee of many Companies, while a Company has one to many Persons as employees.\u003cbr\u003e Observe how we annotate the association in the diagram.\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eContainment\u003c/span\u003e conveys the idea that one object is made up of several others. The relationship implements a whole-part relationship. Under the UML, we can express two different forms of containment:\u003c/p\u003e\r\n\u003cul\u003e\r\n\u003cli\u003eaggregation; and\u003c/li\u003e\r\n\u003cli\u003ecomposition.\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003ch4\u003eAggregation\u003c/h4\u003e\r\n\u003cp\u003e\u003cspan class=\"keyterm\"\u003eAggregation\u003c/span\u003e expresses a \u003cem\u003ewhole-part relationship\u003c/em\u003e in which one object or module contains another module. The key characteristic of an aggregation is that one or more objects are parts of a whole. A more complex function is decomposed into number of simpler functions or modules.\u003c/p\u003e\r\n\u003cp\u003eThe owned module(s) may be \u003cem\u003eshared\u003c/em\u003e with other modules outside of the aggregation. Under such conditions, rules must be established to ensure proper management of the shared module.\u003c/p\u003e\r\n\u003cp\u003eFigure 2.6, below, illustrates a design in which a graphics display is implemented as an aggregate of \u003cspan class=\"italics\"\u003en\u003c/span\u003e windows. Certainly windows can exist outside of the display.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.6—Aggregate\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384269/preview\" alt=\"aggregate\" width=\"344\" height=\"110\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384269\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eThe UML diagram for the aggregation relationship presents both the whole and its parts connected via a solid line that originates from an open diamond on the end associated with the whole and terminates on the end associated with the part.\u003c/p\u003e\r\n\u003ch4\u003eComposition\u003c/h4\u003e\r\n\u003cp\u003eThe \u003cspan class=\"keyterm\"\u003ecomposition\u003c/span\u003e relationship is similar to aggregation. However, the notion of ownership of the parts by the whole is much stronger. Elements of the composition cannot be part of another object, that is, they cannot exist outside of the whole object. The idea is loosely analogous to local variables in a function. Once we leave the scope of the function, the local variables disappear.\u003c/p\u003e\r\n\u003cp\u003eConsider a schedule. It is made up of a number of intervals. Without the schedule, the intervals have no meaning.\u003c/p\u003e\r\n\u003cp\u003eWe express such a relationship as shown in Figure 2.7, below.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.7—Composition\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384288/preview\" alt=\"composition\" width=\"342\" height=\"101\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384288\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eThe schedule is composed of 1 to \u003cspan class=\"italics\"\u003en\u003c/span\u003e intervals. Observe that the diagram is similar to that for the aggregation except that the connecting line now originates from a solid rather than open diamond. We annotate the relationship as a 1 to \u003cspan class=\"italics\"\u003en\u003c/span\u003e composition.\u003c/p\u003e\r\n\u003ch4\u003eDependency\u003c/h4\u003e\r\n\u003cp\u003eAs the term suggests, \u003cspan class=\"keyterm\"\u003edependency\u003c/span\u003e means that one class or object depends on the behavior of another object. This implies that if the public interface or behavior of the class depended upon changes, the dependent class behavior may change, as well. While a goal of good object centered design is to minimize dependence between classes, it can never be eliminated in practice; otherwise we couldn't have any collaboration between objects at all.\u003c/p\u003e\r\n\u003cp\u003eThe best practice is to ensure that you design a persistent public interface for each class that is as simple as possible, using standard naming conventions, with the most general return types. Such an approach allows you to add to the interface later as new requirements present themselves and to change the underlying implementation without changing the interface. You never want to get into a situation where substantial development has taken place and you are forced to make major changes to the public interface of a class, thus requiring many changes to dependent classes.\u003c/p\u003e\r\n\u003cp\u003eDependency is modeled in the UML using a dashed directed line from the dependent class to the class depended on. When dependency represents just the use of a class as an attribute, it is seldom modeled. An example is String class attributes \u003cem\u003efirstName\u003c/em\u003e and \u003cem\u003elastName\u003c/em\u003e in a \u003cem\u003ePerson\u003c/em\u003e class.\u003c/p\u003e\r\n\u003cp\u003eHowever, when a substantial part of the behavior of some class is delegated to another class, the dependency relationship should be modeled. For example, back in the business world, suppose we had an \u003cem\u003eEmployee\u003c/em\u003e class that has a \u003cem\u003ecalculatePay\u003c/em\u003e operation. Further, let the employee's pay be determined not only by the hours worked, but also on one of several different compensation plans, represented by a \u003cem\u003eCompensationPlan\u003c/em\u003e object, with a \u003cem\u003ecalculateCompensation\u003c/em\u003e operation. Such a design represents a substantial delegation of responsibility from Employee to CompensationPlan, and should be modeled as a dependency relationship as we see in Figure 2.8, below.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.8—Dependency\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384282/preview\" alt=\"dependency\" width=\"304\" height=\"75\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384282\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003ch4\u003eInterface\u003c/h4\u003e\r\n\u003cp\u003eAn interface is an inheritance relationship. With an interface only the signatures of the member functions are inheritied. Member function implementation and member data are not part of the interface class, and thus not inheritied. We express an interface in a manner similar to that which we use for inheritance. We use a dashed line terminating in hollow arrow and tag the interface with \u003cem\u003e\u0026lt;\u0026lt;interface\u0026gt;\u0026gt;\u003c/em\u003e. \u003cbr\u003e In Figure 2.9, below, the interface \u003cem\u003estack\u003c/em\u003e gives the underlying array public appearance of a stack.\u003c/p\u003e\r\n\u003cp class=\"title\"\u003e\u003cspan class=\"bold\"\u003eFigure 2.9—Interface\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cimg src=\"https://canvas.uw.edu/courses/1177926/files/44384286/preview\" alt=\"interface\" width=\"269\" height=\"79\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/files/44384286\" data-api-returntype=\"File\"\u003e\u003c/p\u003e\r\n\u003cp\u003eThe operations, \u003cem\u003epush() and pop(),\u003c/em\u003eperform the necessary steps to transform access to the array as necessary.\u003c/p\u003e\r\n\u003ch3\u003eSummary\u003c/h3\u003e\r\n\u003cp\u003eIn this lesson, we have learned several ways in which the C++ language has extended C, including a new library of \u003ccode\u003eiostream\u003c/code\u003e functions to get data into and out of our programs.\u003c/p\u003e\r\n\u003ch3\u003ePractice Questions\u003c/h3\u003e\r\n\u003cp\u003eTest your understanding of the concepts presented in this lesson by working through the following practice questions, then check your answers with \u003ca id=\"\" class=\"\" title=\"Answers to Practice Questions for Lesson 4\" href=\"https://canvas.uw.edu/courses/1177926/pages/answers-to-practice-questions-for-lesson-4\" data-api-endpoint=\"https://canvas.uw.edu/api/v1/courses/1177926/pages/answers-to-practice-questions-for-lesson-4\" data-api-returntype=\"Page\"\u003eAnswers to Practice Questions for Lesson 4\u003c/a\u003e.\u003c/p\u003e\r\n\u003col\u003e\r\n\u003cli\u003eWhat is UML?\u003c/li\u003e\r\n\u003cli\u003eWhat are the main elements of a class diagram?\u003c/li\u003e\r\n\u003cli\u003eWhat are some of the main relationships that can be expressed between classes in a class diagram?\u003c/li\u003e\r\n\u003cli\u003eWhat are CRC cards and what does the acronym stand for?\u003c/li\u003e\r\n\u003c/ol\u003e\r\n\u003c/div\u003e"},"WIKI_PAGE_REVISION":"1","WIKI_PAGE_SHOW_PATH":"/courses/1177926/pages/lesson-4","WIKI_PAGE_EDIT_PATH":"/courses/1177926/pages/lesson-4/edit","WIKI_PAGE_HISTORY_PATH":"/courses/1177926/pages/lesson-4/revisions","COURSE_ID":"1177926","MODULES_PATH":"/courses/1177926/modules","wiki_page_menu_tools":[],"DISPLAY_SHOW_ALL_LINK":false,"badge_counts":{"submissions":0},"notices":[]};
</script>

<script src="./Lesson4_files/navigation_header.bundle-404806ff60.js.download" defer="defer"></script>
<script src="./Lesson4_files/default.js.download" defer="defer"></script>
<script src="./Lesson4_files/custom.js.download" defer="defer"></script>

</div> <!-- #application -->


<div class="ReactTrayPortal"><div data-reactid=".1"></div></div></body></html>